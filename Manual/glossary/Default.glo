<?xml version="1.0" encoding="UTF-8"?>        

<glossgroup id="Default">          
<title>Glossary Definitions</title>        
<glossentry id="Default_absolute">
<glossterm>absolutny</glossterm>
<glossdef>Wartość bezwzględna to taka, w której znak wartości jest ignorowany, zasadniczo przekształcając wszystkie wartości w dodatnie jedynki lub zero. Tak więc - na przykład - wartością bezwzględną dla -10 byłoby 10.</glossdef></glossentry>
<glossentry id="Default_algorithm">
<glossterm>algorytm</glossterm>
<glossdef>Algorytm to w zasadzie zestaw instrukcji lub reguł zaprojektowanych w celu rozwiązania określonego problemu. Problem może być prosty, jak dodanie dwóch liczb lub złożony, jak konwersja pliku wideo z jednego formatu na drugi lub kompresja dźwięku do mniejszego rozmiaru pliku...</glossdef></glossentry>
<glossentry id="Default_anti-aliasing">
<glossterm>antyaliasing</glossterm>
<glossdef>Jest to technika używana do wygładzania w innym przypadku poszarpanych linii lub tekstur poprzez mieszanie koloru krawędzi z kolorem pikseli wokół niej. Rezultatem powinien być bardziej przyjemny i realistyczny wygląd, w zależności od intensywności efektu.</glossdef></glossentry>
<glossentry id="Default_API">
<glossterm>API</glossterm>
<glossdef>Akronim "API" oznacza Application Programming Interface, a to odnosi się do zestawów zasad, rutyn i protokołów używanych do budowania aplikacji. Interfejsy API pomagają w komunikacji z programami lub usługami stron trzecich, które mogą być wykorzystywane do budowania różnego oprogramowania. Firmy takie jak Facebook czy Twitter aktywnie używają API, aby pomóc programistom uzyskać łatwiejszy dostęp do swoich usług, a w GameMaker Studio 2 zobaczysz skrót API używany, gdy mówisz o rozszerzeniach - na przykład Google Play Services API lub Amazon Game On API.</glossdef></glossentry>
<glossentry id="Default_application_surface">
<glossterm>powierzchnia zastosowania</glossterm>
<glossdef>Powierzchnia aplikacji to specjalna wbudowana powierzchnia, do której GameMaker Studio 2 będzie rysował wszystko w zdarzeniach Draw gry (powierzchnia to w zasadzie obszar pamięci zarezerwowany dla grafiki). Powierzchnia ta jest następnie rysowana do bufora wyświetlacza na końcu każdej klatki gry, wyświetlając jego zawartość graczowi.</glossdef></glossentry>
<glossentry id="Default_architectures">
<glossterm>architektury</glossterm>
<glossdef>Architektura układu scalonego procesora (CPU) to opis jego podstawowych elementów oraz podstawowych operacji. Każda rodzina procesorów ma swoją własną architekturę, jak ARM czy x64.</glossdef></glossentry>
<glossentry id="Default_ARGB">
<glossterm>ARGB</glossterm>
<glossdef>Jest to anakronim dla Alfa, Czerwony, Zielony, Niebieski i jest używany do odniesienia do składników koloru określonych jako wartość szesnastkowa, np: #FF53E270, gdzie każdy zestaw dwóch cyfr reprezentuje pojedynczy składnik. Rozbicie powyższego przykładu ARGB daje nam następujące wartości składowe: Alpha(FF), Red(53), Green(E2) i Blue(70).</glossdef></glossentry>
<glossentry id="Default_argument">
<glossterm>argument</glossterm>
<glossdef>Argument (znany również jako parametr) to wartość, która jest przekazywana do funkcji. Na przykład, funkcja języka GameMaker 'sqr(num)' jest funkcją, która da ci kwadrat liczby, którą podasz jako argument, np: 'a = sqr(4);' Tutaj argumentem jest 4, a funkcja zwróci 16, które jest przechowywane w zmiennej 'a'.</glossdef></glossentry>
<glossentry id="Default_asset_key">
<glossterm>klucz do aktywów</glossterm>
<glossdef>Pozycja na osi czasu w dope sheet, w której został umieszczony zasób. Klucz zasobu może trwać wiele klatek.</glossdef></glossentry>
<glossentry id="Default_Asset_Track">
<glossterm>śledzenie aktywów</glossterm>
<glossdef>Ścieżka w panelu ścieżek sekwencji, która zawiera pojedynczy zasób - sprite, dźwięk, instancję lub sekwencję.</glossdef></glossentry>
<glossentry id="Default_assignment">
<glossterm>zadanie</glossterm>
<glossdef>Przypisanie to po prostu określenie, kiedy ustawiamy (przypisujemy) wartość do zmiennej.</glossdef></glossentry>
<glossentry id="Default_backend">
<glossterm>backend</glossterm>
<glossdef>Backend jest częścią programu, która jest wykonywana w tle i jest nieprzejrzysta dla użytkownika, zwykle bez potrzeby jakiejkolwiek interakcji z użytkownikiem. Na przykład, strona serwera podczas programowania sieciowego w Internecie, lub przetwarzanie danych, które dzieje się za kulisami w grze RPG. Jest to w zasadzie przeciwieństwo frontendu.</glossdef></glossentry>
<glossentry id="Default_bezier_interpolation">
<glossterm>interpolacja beziera</glossterm>
<glossdef>Interpolacja Beziera polega na oszacowaniu nowej wartości poprzez połączenie dwóch sąsiednich znanych wartości za pomocą matematycznie wygenerowanej krzywej splajnu, którą można edytować za pomocą "uchwytów" dołączonych do każdego punktu. Następnie możesz uzyskać interpolowaną wartość, sprawdzając dowolny punkt wzdłuż linii.</glossdef></glossentry>
<glossentry id="Default_bit">
<glossterm>bit</glossterm>
<glossdef>Pojedyncza wartość danych, która może być albo 1 albo 0 (prawda lub fałsz). Bity są łączone w bloki po 8, tworząc bajt.</glossdef></glossentry>
<glossentry id="Default_bit_depth">
<glossterm>głębokość bitowa</glossterm>
<glossdef>Głębia bitowa odnosi się do liczby bitów w każdej próbce pliku audio. Mniejsza głębia bitowa daje gorszą jakość dźwięku, ale znacznie mniejszy rozmiar pliku. Niższe głębokości bitowe są zwykle używane dla małych efektów dźwiękowych i patform, gdzie pamięć może być problemem (jak HTML5).</glossdef></glossentry>
<glossentry id="Default_bit_rate">
<glossterm>przepływność</glossterm>
<glossdef>Szybkość bitowa jest mierzona w kilobitach na sekundę (kbps lub k) i jest to liczba bitów zakodowanych na sekundę lub liczba bitów przesyłanych lub odbieranych na sekundę. Im wyższa szybkość bitowa i częstotliwość próbkowania, tym wyższa jakość dźwięku, ale tym więcej mocy obliczeniowej i przepustowości potrzebuje. Niższe stopy bitowe tworzą mniejszy rozmiar pliku i wykorzystują mniej przetwarzania i przepustowości, ale ze spadkiem jakości dźwięku. Dla dobrej jakości muzyki zazwyczaj preferowana jest szybkość bitowa 64-128kbps (zalecana 96kbps).</glossdef></glossentry>
<glossentry id="Default_bitmap">
<glossterm>bitmapa</glossterm>
<glossdef>Bitmapa jest terminem używanym do opisania każdego statycznego obrazu, który składa się z kolorowych pikseli, które są przechowywane jako bity (w przeciwieństwie do obrazów wektorowych, które są przechowywane za pomocą algorytmów matematycznych). PNG, JPG i BMP są przykładami obrazów bitmapowych, podczas gdy SWF byłby przykładem obrazu wektorowego.</glossdef></glossentry>
<glossentry id="Default_boolean">
<glossterm>boolean</glossterm>
<glossdef>Boolean jest typem zmiennej, która może zwrócić wartość true lub false na podstawie jej wartości i może być używana w warunkach i wyrażeniach. Stałe 'false' lub 'true' mogą być zastosowane do boolean, które są odpowiednikiem wartości rzeczywistych 0 i 1.</glossdef></glossentry>
<glossentry id="Default_bounding_box">
<glossterm>ramka ograniczająca</glossterm>
<glossdef>Dla sprite'ów, bounding-box jest nazwą nadaną krawędziom obszaru, w którym początkowo będą wykrywane kolizje, i nie musi mieć tego samego rozmiaru co sprite, do którego jest stosowany. W przypadku sekwencji bounding box jest zewnętrzną krawędzią przestrzeni, którą zajmuje jeden lub więcej obiektów w canvasie.</glossdef></glossentry>
<glossentry id="Default_build_tools">
<glossterm>narzędzia do budowy</glossterm>
<glossdef>Narzędzia do budowania to zewnętrzne aplikacje, których GameMaker Studio 2 wymaga do generowania pakietów wykonywalnych dla różnych platform docelowych.</glossdef></glossentry>
<glossentry id="Default_byte">
<glossterm>bajt</glossterm>
<glossdef>Bajt to jednostka danych o długości ośmiu cyfr binarnych, a każda z cyfr składających się na bajt nazywana jest bitem, tzn. bajt to 8 bitów, a bit może być 1 lub 0.</glossdef></glossentry>
<glossentry id="Default_Cache">
<glossterm>Cache</glossterm>
<glossdef>Cache jest zbiorem plików, które są generowane przez GameMakera raz, a następnie przechowywane i ponownie wykorzystywane przez wiele uruchomień projektu. Zauważ, że ten cache może czasami stać się "nieświeży", co oznacza, że musi zostać wyczyszczony, aby zmusić GameMakera do odbudowania go od nowa, zapewniając, że żadne nieświeże pliki nie uszkodzą twojej ostatecznej gry.</glossdef></glossentry>
<glossentry id="Default_callback">
<glossterm>callback</glossterm>
<glossdef>Wywołanie zwrotne jest po prostu funkcją, która działa, a następnie wyzwala inną funkcję (lub blok kodu), gdy zakończy wykonywanie tego, do czego została przypisana. Na przykład, funkcja sprite_add() wywoła callback w asynchronicznym zdarzeniu Image Loaded, gdy sprite zostanie załadowany.</glossdef></glossentry>
<glossentry id="Default_catmull-rom_interpolation">
<glossterm>interpolacja katmull-rom</glossterm>
<glossdef>Jest to rodzaj interpolacji nieliniowej opartej na splajnach matematycznych. Służy do oszacowania nowej wartości poprzez połączenie dwóch sąsiednich znanych wartości za pomocą "gładkich" krzywych (splinów), a nowa wartość może być wyprowadzona z dowolnego punktu wzdłuż linii.</glossdef></glossentry>
<glossentry id="Default_Compiling">
<glossterm>Kompilacja</glossterm>
<glossdef>Kompilacja to moment, w którym GameMaker bierze Twój kod i zbiera go razem w taki sposób, aby stworzyć pakiet wykonywalny, który będzie działał na urządzeniu jako gra.</glossdef></glossentry>
<glossentry id="Default_compression">
<glossterm>kompresja</glossterm>
<glossdef>Kompresja to wykorzystanie algorytmów matematycznych w celu zmniejszenia rozmiaru pliku. Jest to stosowane w szczególności w przypadku plików audio i obrazów, gdzie formaty takie jak JPG (obraz) i MP3 (dźwięk) są formatami skompresowanymi. Kompresja zwykle powoduje znacznie mniejsze rozmiary plików, ale z pewną utratą danych, które mogą lub nie mogą być zauważalne w zależności od rodzaju i siły zastosowanej kompresji. Formaty nieskompresowane to BMP (obraz) lub WAV (dźwięk), które mają większe rozmiary plików, ale nie powodują utraty danych.</glossdef></glossentry>
<glossentry id="Default_conditional">
<glossterm>warunkowo</glossterm>
<glossdef>Warunki, instrukcje warunkowe i wyrażenia warunkowe są cechami ogólnego języka programowania i pomagają kodowi dokonać wyboru, w którym wynikiem jest prawda lub fałsz. Mogą one wykonywać różne akcje w zależności od potrzeb programisty, a wiele warunków może być połączonych w jeden warunek, tak długo jak wartość końcowa warunku jest prawdziwa lub fałszywa. Przykładami wyrażeń warunkowych są 'if' i 'while'.</glossdef></glossentry>
<glossentry id="Default_constants">
<glossterm>stały</glossterm>
<glossdef>Stała to termin używany do opisania nazwanej wartości, która nie zmienia się podczas wykonywania programu. GameMaker Studio 2 posiada wiele wbudowanych stałych - na przykład os_windows - ale możesz również tworzyć własne stałe wartości do wykorzystania w swoich projektach (zwanych Macros) i rozszerzeniach.</glossdef></glossentry>
<glossentry id="Default_CPU_overhead">
<glossterm>Koszty ogólne procesora</glossterm>
<glossdef>Obciążenie procesora mierzy ilość pracy, jaką może wykonać centralna jednostka obliczeniowa komputera oraz procent tej zdolności, który jest wykorzystywany przez poszczególne zadania obliczeniowe.</glossdef></glossentry>
<glossentry id="Default_deadzone">
<glossterm>deadzone</glossterm>
<glossdef>Strefa martwa to odległość, na jaką musisz przesunąć drążek analogowy, zanim gra rozpozna, że został on przesunięty. Niska wartość strefy martwej sprawi, że każdy niewielki ruch drążka analogowego spowoduje poruszenie gracza, celowanie lub cokolwiek innego. Wysoka wartość strefy martwej oznacza, że drążek analogowy musi wykonać znacznie większy ruch, zanim gra go wykryje i poruszy tym, co jest sterowane.</glossdef></glossentry>
<glossentry id="Default_back-buffer">
<glossterm>bufor wyświetlacza</glossterm>
<glossdef>Bufor wyświetlania jest "płótnem", na którym wszystko jest ostatecznie rysowane. Niektóre zdarzenia są skierowane bezpośrednio do tego miejsca (jak np. zdarzenie Pre Draw), podczas gdy inne najpierw rysują do powierzchni aplikacji, a następnie rysują do bufora wyświetlacza.</glossdef></glossentry>
<glossentry id="Default_Dope_Sheet">
<glossterm>Dope Sheet</glossterm>
<glossdef>Dope Sheet to wizualna reprezentacja osi czasu sekwencji, gdzie można dodawać, usuwać i edytować różne klucze zasobów i parametry, które wpływają na to, jak poszczególne ścieżki w sekwencji będą się zachowywać w czasie.</glossdef></glossentry>
<glossentry id="Default_encoding">
<glossterm>kodowanie</glossterm>
<glossdef>Kodowanie przekształca dane w inny format przy użyciu schematu, który jest publicznie dostępny, tak aby można go było łatwo odwrócić. Nie jest to to samo co szyfrowanie, ponieważ nie wymaga klucza do rozszyfrowania. Kodowanie jest zazwyczaj używane do zmiany danych na format łatwiejszy do wykorzystania przez inny system (np. wysyłanie danych na serwer) lub do uczynienia danych nieczytelnymi dla ludzkiego oka.</glossdef></glossentry>
<glossentry id="Default_EULA">
<glossterm>EULA</glossterm>
<glossdef>Umowa licencyjna użytkownika końcowego (EULA) jest dokumentem prawnym, który przedstawia licencję na produkt, który otrzymujesz.</glossdef></glossentry>
<glossentry id="Default_exception">
<glossterm>wyjątek</glossterm>
<glossdef>Specjalny, nieoczekiwany i anomalny stan napotkany podczas wykonywania programu nazywany jest wyjątkiem. Można go również określić jako błąd lub stan, który zmienia drogę programu lub mikroprocesora na inną. Przykładem wyjątku może być przypadek, gdy program próbuje uzyskać dostęp do zmiennej, ale ta zmienna nie istnieje. Wyjątki muszą być obsługiwane i eliminowane w kodzie programu, aby uniknąć błędu śmiertelnego, proces ten nazywa się debugowaniem.</glossdef></glossentry>
<glossentry id="Default_executable_package">
<glossterm>pakiet wykonywalny</glossterm>
<glossdef>Pakiet plików, które są używane do wykonania programu. W GameMaker Studio może to być pojedynczy plik - jak instalator dla Windows - lub wiele plików - jak wyjście HTML5.</glossdef></glossentry>
<glossentry id="Default_expression">
<glossterm>wyraz</glossterm>
<glossdef>Wyrażenie jest kombinacją jednej lub więcej stałych, zmiennych, operatorów i/lub funkcji, które są interpretowane zgodnie z określonymi zasadami pierwszeństwa i asocjacji w celu zwrócenia innej wartości. Prostym wyrażeniem byłoby (5 5), które zwraca 10.</glossdef></glossentry>
<glossentry id="Default_falsy">
<glossterm>falsy</glossterm>
<glossdef>Wartość, która jest uważana za "fałszywą", gdy jest używana jako boolean, na przykład w warunku if().</glossdef></glossentry>
<glossentry id="Default_floating_point">
<glossterm>zmiennoprzecinkowy</glossterm>
<glossdef>Liczby zmiennoprzecinkowe to liczby, które zawierają punkty dziesiętne. Na przykład liczby 5,5, 0,001 i -2 345,6789 są liczbami zmiennoprzecinkowymi. Liczby, które nie mają miejsc dziesiętnych nazywane są liczbami całkowitymi (np. 2, 56, 1400).</glossdef></glossentry>
<glossentry id="Default_font">
<glossterm>czcionka</glossterm>
<glossdef>Czcionka to zbiór graficznych glifów używanych do reprezentacji tekstu w danym języku. Czcionki mogą mieć różne wagi, rozmiary i style i są używane do wyświetlania dowolnej zawartości pisemnej w projekcie.</glossdef></glossentry>
<glossentry id="Default_framework">
<glossterm>rama</glossterm>
<glossdef>Szkielet to podstawa kodu, który może być zmieniany i/lub rozbudowywany przez użytkownika. Szkielet może zawierać różne biblioteki programistyczne, API, kompilatory i wiele innych. Mówiąc prościej, framework zapewnia korzystne środowisko dla określonego typu i poziomu programowania projektu. W GameMaker Studio 2 możesz na przykład tworzyć własne projekty szkieletowe (poprzez Local Asset Packages), które zawierają skrypty i obiekty do ogólnego sterowania, zarządzania statystykami, sieci lub czegokolwiek innego, czego używasz w swoich projektach, a następnie importować je do nowych projektów na samym początku, aby dać ci podstawy do kontynuowania pracy bez konieczności przeprogramowywania tych systemów za każdym razem.</glossdef></glossentry>
<glossentry id="Default_frontend">
<glossterm>frontend</glossterm>
<glossdef>Frontend jest częścią programu, która jest "skierowana do przodu", tj. częścią, z którą użytkownik końcowy wchodzi w interakcję. Na przykład w GameMaker Studio 2 interfejs, w którym programujesz i dodajesz zasoby, itd... jest frontendem programu, ponieważ to tam wchodzisz w interakcję z programem i wprowadzasz wartości, pliki i inne rzeczy. Jest to zasadniczo przeciwieństwo backendu.</glossdef></glossentry>
<glossentry id="Default_GameMaker:_Studio 1.4">
<glossterm>GameMaker: Studio 1.4</glossterm>
<glossdef>Poprzednia wersja oprogramowania GameMaker (często nazywana Legacy GameMaker), która nie jest już dostępna ani wspierana.</glossdef></glossentry>
<glossentry id="Default_garbage_collector">
<glossterm>śmieciarz</glossterm>
<glossdef>Garbage collector jest automatycznym narzędziem, które jest częścią kodu gry i jest używane do usuwania pewnych rzeczy (takich jak tablice i struktury) z pamięci, gdy nie ma już do nich odniesień w twoim kodzie, bez potrzeby wyraźnego usuwania ich przez użytkownika.</glossdef></glossentry>
<glossentry id="Default_gizmos">
<glossterm>gizmosy</glossterm>
<glossdef>Gizmo są bezpośrednio manipulowalnymi, samowystarczalnymi, wizualnymi idiomami ekranowymi - zasadniczo wszystko, co jest wizualne i może być poddane interakcji lub manipulacji przez użytkownika w celu wygenerowania efektu lub konkretnego rezultatu.</glossdef></glossentry>
<glossentry id="Default_GUI">
<glossterm>GUI</glossterm>
<glossdef>Skrót od "Graphical User Interface", czyli interfejs użytkownika, który zawiera elementy graficzne, takie jak okna, ikony i przyciski. W GameMakerze masz specyficzny zestaw zdarzeń obiektów (Draw GUI Events), które mogą rysować do tej warstwy specjalnie zaprojektowanej dla takich rzeczy jak wynik, życia, zapasy, itp.</glossdef></glossentry>
<glossentry id="Default_hard-code">
<glossterm>twardo zakodowany</glossterm>
<glossdef>W programowaniu komputerowym termin hard-coded jest używany do opisania kodu, który jest uważany za stały i mało prawdopodobny do zmiany. Funkcje hardcoded są wbudowane w sprzęt lub oprogramowanie w taki sposób, że nie mogą być później modyfikowane. Na przykład, jeśli tworzysz grę i "twardo" kodujesz zdrowie gracza na 10, to będziesz używał wartości 10 w całym kodzie gry, zamiast używać zmiennej.</glossdef></glossentry>
<glossentry id="Default_hashing">
<glossterm>haszowanie</glossterm>
<glossdef>Hashing to metoda tworzenia ciągu lub wartości, która odnosi się do pojedynczego źródła - zwykle pliku - i TYLKO tego źródła. Na przykład w GameMakerze możesz wygenerować hash dla pliku zapisu, a następnie, przed uzyskaniem dostępu do niego później, wygenerować inny hash dla niego i sprawdzić oryginalny hash i nowy hash, aby określić, czy plik został naruszony.</glossdef></glossentry>
<glossentry id="Default_HVS">
<glossterm>HSV</glossterm>
<glossdef>Jest to skrót od Hue (barwa), Saturation (nasycenie) i Value (wartość) i jest to sposób wyrażania koloru zazwyczaj przy użyciu wartości od 0 do 255. Barwa to wartość odcienia koloru, nasycenie to ilość używanego koloru, a wartość to jasność koloru.</glossdef></glossentry>
<glossentry id="Default_HUD">
<glossterm>HUD</glossterm>
<glossdef>W grach, HUD oznacza Heads-Up Display. Jest to metoda, za pomocą której informacje są wizualnie przekazywane do gracza jako część interfejsu użytkownika gry, więc rzeczy takie jak pasek zdrowia, ikony statusu, wynik, itp... wszystkie tworzą część HUD, i normalnie elementy HUD nie wymagają interakcji użytkownika.</glossdef></glossentry>
<glossentry id="Default_IDE">
<glossterm>IDE</glossterm>
<glossdef>IDE, czyli Integrated Development Environment, to aplikacja, która dostarcza programistom komputerowym wszechstronnych udogodnień w zakresie tworzenia oprogramowania. W tym przypadku cały frontend GameMaker Studio 2 jest uważany za IDE i zawiera sekcje do tworzenia grafiki, dodawania dźwięków i dodawania kodu do tworzenia gier.</glossdef></glossentry>
<glossentry id="Default_iteration">
<glossterm>iteracja</glossterm>
<glossdef>Iteracja to pojedyncze przejście przez zestaw operacji w twoim kodzie projektu. Jedną z form iteracji w programowaniu komputerowym są pętle. Pętla powtarza pewien segment kodu, dopóki nie zostanie spełniony warunek i nie będzie można przejść dalej. Za każdym razem, gdy komputer uruchamia pętlę, jest ona znana jako iteracja. W uproszczeniu, iteracja to proces powtarzania określonego fragmentu kodu w kółko w celu wykonania określonej akcji.</glossdef></glossentry>
<glossentry id="Default_JSON">
<glossterm>JSON</glossterm>
<glossdef>JSON oznacza JavaScript Object Notatio i jest lekkim formatem przechowywania danych. JSON jest często używany, gdy dane są wysyłane z serwera do strony internetowej i jest uważany za "samoopisujący" i łatwy do zrozumienia i śledzenia, gdy jest oglądany.</glossdef></glossentry>
<glossentry id="Default_keyframe">
<glossterm>klatka kluczowa</glossterm>
<glossdef>Klatka kluczowa (zwana również kluczem parametrów) jest punktem na osi czasu w arkuszu dope, w którym zdefiniowana jest zmiana wartości parametru.</glossdef></glossentry>
<glossentry id="Default_keyword">
<glossterm>słowo kluczowe</glossterm>
<glossdef>Słowa kluczowe to specjalne słowa, które są zarezerwowane przez język programowania lub program, ponieważ mają specjalne znaczenie. Te słowa kluczowe są zarezerwowane do wykonywania określonych zadań i mogą być zarówno poleceniami, jak i parametrami. Każdy język programowania ma zestaw zarezerwowanych słów kluczowych (znanych również jako zarezerwowane nazwy), które nie mogą być używane jako nazwy zmiennych, a język GameMaker nie jest wyjątkiem, gdzie słowa takie jak return, while, if i break są wszystkimi zarezerwowanymi słowami kluczowymi używanymi w języku programowania.</glossdef></glossentry>
<glossentry id="Default_linear_interpolation">
<glossterm>interpolacja liniowa</glossterm>
<glossdef>Interpolacja liniowa polega na oszacowaniu nowej wartości poprzez połączenie dwóch sąsiednich znanych wartości linią prostą. Następnie można uzyskać interpolowaną wartość, sprawdzając dowolny punkt wzdłuż linii. W grafice interpolacja liniowa odnosi się do podstawowej metody wygładzania krawędzi pikseli.</glossdef></glossentry>
<glossentry id="Default_literal">
<glossterm>dosłowny</glossterm>
<glossdef>Jawna wartość zapisana w kodzie, np. kiedy piszesz "A TEXT STRING" używasz literału łańcuchowego, w przeciwieństwie do zwracania łańcucha przez zmienną lub funkcję. Podobnie, [0, 1, 2] jest literałem tablicowym.</glossdef></glossentry>
<glossentry id="Default_machine_code">
<glossterm>kod maszynowy</glossterm>
<glossdef>Kod maszynowy to kod, który jest bezpośrednio wykonywany przez procesor bez potrzeby interpretacji przez interpreter. Jest to najniższy poziom kodu i zawiera instrukcje, które wykonuje procesor.Jest on specyficzny dla architektury procesora. W związku z tym jest zoptymalizowany. Może być również wygenerowany z kodu źródłowego w języku programowania wyższego poziomu przez kompilator.W GameMakerze kompilator YoYo może być użyty do wygenerowania pliku wykonywalnego zawierającego zoptymalizowany kod maszynowy dla różnych platform.</glossdef></glossentry>
<glossentry id="Default_method">
<glossterm>metoda</glossterm>
<glossdef>W GameMakerze metoda to nazwa nadana funkcji zdefiniowanej przez użytkownika, która została powiązana z instancją, tak że zmienna instancji jest nazwą funkcji i tym, czego używasz do jej wywołania.</glossdef></glossentry>
<glossentry id="Default_operand">
<glossterm>operand</glossterm>
<glossdef>Operand to termin używany do oznaczenia wartości, którymi można manipulować przy użyciu różnych operatorów. W wyrażeniu A B C, A, B i C są operandami.</glossdef></glossentry>
<glossentry id="Default_operator">
<glossterm>operator</glossterm>
<glossdef>Operator to termin używany do oznaczenia czegoś, co może manipulować różnymi operandami. W wyrażeniu A B - C, i - są operatorami. Przykłady różnych operatorów to (dodawanie), - (odejmowanie), = (równe), != (nie równe) i >= (większe lub równe), ale jest ich o wiele więcej.</glossdef></glossentry>
<glossentry id="Default_parameter_key">
<glossterm>klucz do parametrów</glossterm>
<glossdef>Klucz parametrów (zwany również klatką kluczową) jest punktem na osi czasu w arkuszu dope, w którym zdefiniowana jest zmiana wartości parametru.</glossdef></glossentry>
<glossentry id="Default_parameter_tracks">
<glossterm>ścieżki parametrów</glossterm>
<glossdef>Ścieżka, która została przypisana do ścieżki aktywów w panelu ścieżek i która zmienia pojedynczy parametr ścieżki aktywów, z którą jest połączona, taki jak pozycja lub indeks obrazu.</glossdef></glossentry>
<glossentry id="Default_physics">
<glossterm>fizyka</glossterm>
<glossdef>W GameMakerze, kiedy mówimy o obiekcie, instancji lub pomieszczeniu używającym "fizyki", mamy na myśli, że korzysta ono z wbudowanych funkcji symulacji fizyki, opartych na bibliotece fizyki Box2D.</glossdef></glossentry>
<glossentry id="Default_playhead">
<glossterm>playhead</glossterm>
<glossdef>Bieżąca pozycja "odtwarzania" na osi czasu w arkuszu sekwencji lub w widoku klatek edytora sprajtów. W sekwencjach (i sprite'ach) pozycja ta będzie się przesuwać w miarę podglądu animacji i możesz ją umieścić na konkretnych klatkach, aby zobaczyć i edytować klucze i klatki kluczowe w tej pozycji.</glossdef></glossentry>
<glossentry id="Default_port_number">
<glossterm>numer portu</glossterm>
<glossdef>Numer portu jest sposobem identyfikacji konkretnego procesu, do którego ma być przekazana wiadomość z Internetu lub innej sieci po jej dotarciu do serwera.</glossdef></glossentry>
<glossentry id="Default_PURE">
<glossterm>czysty</glossterm>
<glossdef>Czysta funkcja nie ma wpływu na grę, nie tworzy ani nie zmienia niczego. Zwraca jedynie wartość. Biorąc pod uwagę ten sam zestaw argumentów, zawsze zwraca tę samą wartość.</glossdef></glossentry>
<glossentry id="Default_Remote_Workers">
<glossterm>Pracownicy zdalni</glossterm>
<glossdef>Remote Worker to specjalny program, którego GameMaker Studio 2 będzie używał na niektórych platformach do tworzenia plików wykonawczych gier bez konieczności uruchamiania GameMaker Studio 2 IDE na tej platformie.</glossdef></glossentry>
<glossentry id="Default_render">
<glossterm>renderowane</glossterm>
<glossdef>Kiedy coś jest renderowane w GameMaker Studio 2, oznacza to, że zostało po prostu "narysowane do bufora wyświetlacza" lub "narysowane na powierzchni".  Renderowanie może również odnosić się do procesu przekształcania pewnego rodzaju źródła wektorowego (jak czcionka) w obraz bitmapowy.</glossdef></glossentry>
<glossentry id="Default_RSS">
<glossterm>RSS</glossterm>
<glossdef>Skrót od "Rich Site Summary" i jest ustandaryzowanym systemem dystrybucji treści od wydawcy internetowego do użytkowników Internetu.</glossdef></glossentry>
<glossentry id="Default_Runtime">
<glossterm>Runtime</glossterm>
<glossdef>Runtime w GameMaker Studio 2 to zbiór zasobów kompilatora, które są wymagane przez program do stworzenia ostatecznego pakietu wykonywalnego dla danej platformy docelowej. Są one instalowane oddzielnie od IDE i mogą być zmieniane i aktualizowane w dowolnym momencie.</glossdef></glossentry>
<glossentry id="Default_sample_rate">
<glossterm>częstotliwość próbkowania</glossterm>
<glossdef>Częstotliwość próbkowania to liczba próbek dźwięku przenoszonych na sekundę, mierzona w Hz lub kHz (jeden kHz to 1000 Hz). Im wyższa częstotliwość próbkowania, tym bardziej dźwięk będzie zbliżony do oryginalnego analogowego kształtu fali, ale tym większy będzie rozmiar pliku. Ogólnie rzecz biorąc, efekty dźwiękowe mogą być odtwarzane z niższą częstotliwością próbkowania niż muzyka.</glossdef></glossentry>
<glossentry id="Default_SCM">
<glossterm>SCM</glossterm>
<glossdef>SCM to skrót od Source Control Management, który jest programem (lub zestawem programów) odpowiedzialnym za utrzymywanie wersji kodu źródłowego dla danego projektu. SCM pozwala m.in. na przechowywanie bieżącej historii zmian kodu, a także na przeglądanie i cofanie wszelkich zmian dokonanych w kodzie źródłowym.</glossdef></glossentry>
<glossentry id="Default_SDK">
<glossterm>SDK</glossterm>
<glossdef>SDK to skrót od "Software Development Kit". Zazwyczaj odnosi się to do zbioru oprogramowania i/lub pakietów używanych do tworzenia aplikacji dla konkretnego urządzenia lub systemu operacyjnego.</glossdef></glossentry>
<glossentry id="Default_server">
<glossterm>serwer</glossterm>
<glossdef>W informatyce serwer to program komputerowy lub urządzenie, które zapewnia funkcjonalność innym programom lub urządzeniom, zwanym "klientami".</glossdef></glossentry>
<glossentry id="Default_shader">
<glossterm>shadery</glossterm>
<glossdef>Shader to zbiór małych programów, które są uruchamiane bezpośrednio na procesorze graficznym w celu tworzenia grafiki i efektów graficznych. Są one bardzo szybkie w działaniu i uwalniają CPU do innych zadań.</glossdef></glossentry>
<glossentry id="Default_smooth_interpolation">
<glossterm>płynna interpolacja</glossterm>
<glossdef>Płynna interpolacja polega na oszacowaniu nowej wartości poprzez połączenie dwóch sąsiednich znanych wartości za pomocą matematycznie wygenerowanej krzywej spline . Następnie możesz uzyskać interpolowaną wartość, sprawdzając dowolny punkt wzdłuż linii.</glossdef></glossentry>
<glossentry id="Default_source_code">
<glossterm>kod źródłowy</glossterm>
<glossdef>Kod źródłowy to podstawowy składnik programu komputerowego, który jest wymagany do jego uruchomienia.</glossdef></glossentry>
<glossentry id="Default_spline">
<glossterm>klinowy</glossterm>
<glossdef>Splajn to w zasadzie gładka krzywa używana do łączenia punktów. Matematycznie rzecz biorąc, jest to wystarczająco gładka funkcja wielomianowa, która jest określona w kawałkach i posiada wysoki stopień gładkości w miejscach, gdzie kawałki wielomianu łączą się.</glossdef></glossentry>
<glossentry id="Default_sprites">
<glossterm>sprite'y</glossterm>
<glossdef>Sprite to grafika bitmapowa, która jest przeznaczona do bycia częścią większej sceny. Może to być zarówno statyczny obraz jak i animowana grafika.</glossdef></glossentry>
<glossentry id="Default_statement">
<glossterm>oświadczenie</glossterm>
<glossdef>W programowaniu, instrukcja jest pojedynczą linią kodu napisaną legalnie w języku programowania, która wyraża akcję do wykonania. Instrukcja może mieć swoje wewnętrzne składniki, w tym wyrażenia, operatory i funkcje. Przykładem polecenia jest A = B 5. Program GameMaker Studio 2 to nic innego jak sekwencja jednego lub więcej stwierdzeń, które razem wykonują jakieś zadanie (np. poruszają gracza).</glossdef></glossentry>
<glossentry id="Default_swatches">
<glossterm>swatche</glossterm>
<glossdef>Próbka to po prostu mała kwadratowa próbka koloru lub materiału używana do zilustrowania tego, jak będzie wyglądać.</glossdef></glossentry>
<glossentry id="Default_syntax">
<glossterm>składnia</glossterm>
<glossdef>Podobnie jak języki ludzkie, języki programowania mają swój własny zestaw reguł dotyczących sposobu przekazywania wypowiedzi, a ten zestaw reguł znany jest jako składnia. Podczas gdy wiele języków programowania ma wiele wspólnych cech, funkcji i możliwości, różnią się one na ogół składnią. Bez właściwego użycia składni nie można napisać programu wykonywalnego, a niewłaściwa składnia będzie prowadzić do błędów podczas kompilacji.</glossdef></glossentry>
<glossentry id="Default_texel">
<glossterm>texel</glossterm>
<glossdef>Texel (lub element tekstury) jest podstawową jednostką przestrzeni tekstury, podobnie jak piksel jest podstawowym elementem przestrzeni obrazu. Tekstury są reprezentowane przez tablice tekseli, tak jak obrazy są reprezentowane przez tablice pikseli. Podczas teksturowania powierzchni 3D (proces znany jako mapowanie tekstury) renderer mapuje teksele na odpowiednie piksele w obrazie wyjściowym.</glossdef></glossentry>
<glossentry id="Default_texture_atlas">
<glossterm>atlas tekstur</glossterm>
<glossdef>Inna nazwa strony tekstur, która jest po prostu zbiorem obrazów wymaganych przez jeden lub więcej sprite'ów w Twojej grze, zorganizowanych w optymalny sposób, aby wykorzystać jak najmniej pamięci tekstur.</glossdef></glossentry>
<glossentry id="Default_texture_page">
<glossterm>strona z teksturą</glossterm>
<glossdef>Strona tekstur (zwana również atlasem tekstur) jest zbiorem obrazów (sprite'ów, tilesetów, znaków czcionek, itd...), które są pogrupowane w optymalny sposób, tak aby zajmowały jak najmniej pamięci tekstur podczas uruchamiania gry.</glossdef></glossentry>
<glossentry id="Default_tile_map">
<glossterm>mapa płytek</glossterm>
<glossdef>Mapa kafelkowa to nazwa nadana kolekcji kafelków pobranych z zestawu kafelków i używanych do tworzenia poziomów w grze.</glossdef></glossentry>
<glossentry id="Default_tile-sets">
<glossterm>zestawy płytek</glossterm>
<glossdef>Zestaw płytek to zbiór kwadratowych lub prostokątnych elementów graficznych ułożonych na siatce jako jeden obraz. Każdy element w siatce może być następnie wielokrotnie umieszczony w pomieszczeniu, aby stworzyć większą scenę zwaną "mapą kafelkową".</glossdef></glossentry>
<glossentry id="Default_timeline">
<glossterm>harmonogramy</glossterm>
<glossdef>Oś czasu w GameMaker Studio 2 to liniowa kolekcja zdarzeń, które będą uruchamiane w kolejności. Każdemu zdarzeniu można nadać kod lub akcję, aby wykonać zadanie i kiedy linia czasu jest uruchamiana, zadania te będą wykonywane po osiągnięciu każdego zdarzenia w linii czasu.</glossdef></glossentry>
<glossentry id="Default_Track_Panel">
<glossterm>Panel ścieżek</glossterm>
<glossdef>Obszar edytora sekwencji, który pokazuje wszystkie różne ścieżki w sekwencji - ścieżki zasobów, ścieżki parametrów, grupy ścieżek i grupy masek klipów.</glossdef></glossentry>
<glossentry id="Default_truth_table">
<glossterm>tabela prawdy</glossterm>
<glossdef>Tablica prawdy to tabela matematyczna stosowana w logice - w szczególności w związku z algebrą boolowską i funkcjami boolowskimi - która określa wartości funkcyjne wyrażeń logicznych na każdym z ich argumentów funkcyjnych, czyli dla każdej kombinacji wartości przyjmowanych przez ich zmienne logiczne.</glossdef></glossentry>
<glossentry id="Default_truthy">
<glossterm>prawda</glossterm>
<glossdef>Wartość, która jest uważana za "prawdziwą", gdy jest używana jako boolean, na przykład w warunku if().</glossdef></glossentry>
<glossentry id="Default_typo">
<glossterm>literówka</glossterm>
<glossdef>Błąd typograficzny.</glossdef></glossentry>
<glossentry id="Default_URL">
<glossterm>URL</glossterm>
<glossdef>Skrót od "Universal Resource Locator" i jest to w zasadzie adres czegoś w Internecie.</glossdef></glossentry>
<glossentry id="Default_v-sync">
<glossterm>v-sync</glossterm>
<glossdef>V-sync lub synchronizacja pionowa służy do synchronizacji prędkości aktualizacji gry z częstotliwością odświeżania monitora. Może to zredukować zjawisko screen tearingu - czyli wyświetlania fragmentów wielu klatek za jednym razem - ale może też powodować problemy z wydajnością lub problemy na monitorach o wysokiej częstotliwości odświeżania.</glossdef></glossentry>
<glossentry id="Default_variable">
<glossterm>zmienna</glossterm>
<glossdef>Zmienna to nazwana wartość w programie, która może być modyfikowana, przechowywana i wyświetlana, gdy jest to wymagane. Na przykład, jeśli mamy zmienną całkowitą o nazwie XYZ i przechowuje ona wartość 10, możemy wykonać takie czynności jak A = XYZ 10, co spowoduje ustawienie wartości zmiennej A na 20, ponieważ XYZ wynosi 10, a my dodajemy do niej 10. Można również zmieniać wartości zmiennych za pomocą operatorów, więc wykonanie XYZ = XYZ 100 zmodyfikuje wartość naszej zmiennej XYZ, aby była równa 110. Zmienne mogą być również używane do przechowywania identyfikatorów i odniesień do różnych zasobów.</glossdef></glossentry>
<glossentry id="Default_vector">
<glossterm>wektor</glossterm>
<glossdef>Wektor jest konstrukcją matematyczną, która posiada rozmiar, zwany wielkością, oraz kierunek. W GameMakerze, wektor jest zwykle używany do pokazania odległości i kierunku, w którym coś się poruszyło. Wektor może być również użyty do definiowania obrazów, a niektóre formaty obrazów, takie jak SWF, używają matematyki wektorowej do definiowania obrazów, które zawierają.</glossdef></glossentry>
<glossentry id="Default_Version_Number">
<glossterm>Numer wersji</glossterm>
<glossdef>Numer wersji to unikalny zestaw liczb przypisany do konkretnego wydania programu, gry lub zasobów, zwykle w formacie MAJOR.MINOR.MAINTENANCE, np. v2.3.56. Zazwyczaj, w miarę wydawania aktualizacji i całkowicie nowych edycji gry lub zasobów, numer wersji będzie wzrastał.</glossdef></glossentry>
<glossentry id="Default_vertex">
<glossterm>punkt</glossterm>
<glossdef>Werteks to nazwa nadana pojedynczemu punktowi wielokąta, który zawiera różne cechy określające jego położenie, kolor i teksturę. W grafice komputerowej oznacza to zwykle narożnik trójkąta, który jest używany do tworzenia prymitywów, a kombinacja takich prymitywów jest tym, co tworzy grafikę na ekranie.</glossdef></glossentry>
<glossentry id="Default_virtual_machine">
<glossterm>Maszyna wirtualna (VM)</glossterm>
<glossdef>W GameMakerze VM (Virtual Machine) jest metodą kompilacji, która używa generycznego runnera dla każdej platformy, a następnie używa go do interpretacji kodu dla twojej gry.</glossdef></glossentry>
<glossentry id="Default_VRAM">
<glossterm>VRAM</glossterm>
<glossdef>VRAM to ilość pamięci dostępnej dla wideo, czyli przestrzeń pamięci, która może przechowywać tekstury i obrazy.</glossdef></glossentry>
<glossentry id="Default_weak_reference">
<glossterm>słabe odniesienie</glossterm>
<glossdef>Słabe odniesienie to odniesienie, które nie chroni obiektu odniesienia przed zbieraniem przez garbage collector, a więc może być użyte do sprawdzenia, czy struct jest wciąż "żywy" (odniesiony) lub nie gdzieś w grze.</glossdef></glossentry>
<glossentry id="Default_YoYo_Compiler">
<glossterm>YoYo Compiler (YYC)</glossterm>
<glossdef>Jest to specjalny kompilator do tworzenia pakietów wykonywalnych, które używają natywnego kodu zamiast kodu interepretowanego i runnera (który jest tym, czego używa kompilacja GameMaker VM). Skompilowany kod jest szybszy do uruchomienia, ale zajmuje więcej czasu, aby skompilować plik wykonywalny.</glossdef></glossentry>
<glossentry id="Default_multicast">
<glossterm>multicast</glossterm>
<glossdef>Multicast to komunikacja sieciowa, w której zamiast pojedynczego odbiorcy w jednej transmisji adresowanych jest wielu odbiorców.</glossdef></glossentry></glossgroup>