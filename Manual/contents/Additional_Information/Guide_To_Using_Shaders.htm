<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Przewodnik po używaniu shaderów</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <script src="../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page that explains how to set up and use shaders" />
  <meta name="rh-index-keywords" content="Guide To Using Shaders" />
  <meta name="search-keywords" content="shaders,shader,use shaders,shader guide,shader setup,shader examples,shader example" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Przewodnik po używaniu shaderów</h1>
  <p>Shadery są często używane do tworzenia pięknych efektów graficznych w grach. Należą one również do najbardziej zaawansowanych funkcji oferowanych przez <span data-keyref="GameMaker Name">GameMakera</span>, więc konieczne jest, abyś miał podstawowe zrozumienie programowania i działania <span data-keyref="GameMaker Name">GameMakera</span> przed rozpoczęciem pracy z nimi.</p>
  <p>Czym więc jest <span class="notranslate">shader</span>? Początkowo były one tworzone w celu zapewnienia cieniowania dla oświetlenia (stąd nazwa), ale obecnie są wykorzystywane do tworzenia ogromnej liczby efektów. Kod <span class="notranslate">Shader</span> jest podobny do zwykłego kodu, ale jest (prawie zawsze) wykonywany przez GPU, a nie CPU. Ta różnica wiąże się z własnym zestawem zasad i ograniczeń, ale o tym później.</p>
  <p>Każdy <span class="notranslate">shader</span> składa się z dwóch oddzielnych komponentów: <strong>wierzchołka <span class="notranslate">shader</span> </strong>i <strong>fragmentu <span class="notranslate">shader</span> </strong>(zwanego również <strong>pixel shader</strong>). Zacznijmy od <span class="notranslate">vertex</span> <span class="notranslate">shader</span>. Każdy <span class="notranslate">sprite</span> jest utworzony przez prostokąt, ale komputery lubią rysować trójkąty, więc te prostokąty są dzielone na dwa trójkąty (czasami nazywane <em>quadami</em>). To pozostawia nam sześć wierzchołków (narożników) na <span class="notranslate">sprite</span>, ale dwa z nich są takie same, więc powinniśmy się martwić tylko o cztery. Teraz wyobraźmy sobie, że mamy for <span class="notranslate">loop</span>, który przechodzi przez każdą <span class="notranslate">vertex</span> i wykonuje kod wewnątrz <span class="notranslate">vertex</span> <span class="notranslate">shader</span> dla każdego z nich. To pozwala nam zmienić pozycję i kolor <span class="notranslate">vertex</span> przed przekazaniem go do fragmentu <span class="notranslate">shader</span>, ponieważ <span class="notranslate">vertex</span> <span class="notranslate">shader</span> jest wykonywany wcześniej.</p>
  <p>Oto jak to by wyglądało:</p>
  <p><img>Dla fragmentu <span class="notranslate">shader</span>, możesz wyobrazić sobie ten sam <span class="notranslate">loop</span> co wcześniej, ale tym razem przechodzi przez każdy pojedynczy piksel w twoim <span class="notranslate">sprite</span>, dając ci informacje takie jak lokalizacja i kolor tego piksela. W swoim kodzie fragmentu <span class="notranslate">shader</span> wykonujesz operacje i obliczenia, aby określić kolor tego piksela, aby uzyskać pożądany efekt. Na przykład, jeśli chcesz, aby <span class="notranslate">shader</span> sprawił, że twoja <span class="notranslate">sprite</span> będzie czarno-biała, wtedy obliczysz, jaki odcień szarości musi mieć każdy piksel, aby stworzyć ten efekt.</p>
  <p>Wyglądałoby to coś takiego:</p>
  <p><img>Powodem, dla którego kod <span class="notranslate">shader</span> jest zazwyczaj wykonywany przez GPU jest to, że jest on w tym bardziej wydajny. Nowoczesne procesory posiadają zazwyczaj od dwóch do ośmiu rdzeni. Każdy rdzeń może wykonywać jedno zadanie w tym samym czasie, więc wykorzystując wiele rdzeni, możemy wykonywać tyle zadań jednocześnie. Dla kontrastu, nowoczesne procesory graficzne mogą wykonywać tysiące, a nawet dziesiątki tysięcy zadań w tym samym czasie. Jest to pomocne dla <span class="notranslate">shaders</span>, ponieważ możemy wykonywać kod <span class="notranslate">shader</span> tysięcy pikseli jednocześnie. Ograniczeniem jest to, że mamy dostęp tylko do stanu początkowego <span class="notranslate">sprite</span>, więc nie wiemy o żadnych modyfikacjach wykonanych na innych pikselach, ponieważ nie możemy mieć pewności, że kod został jeszcze na nich uruchomiony.</p>
  <p class="note"><strong>UWAGA</strong>: <span data-keyref="GameMaker Name">GameMaker</span> pozwala pisać <span class="notranslate">shaders</span> w <strong>GLSL</strong> (OpenGL <span class="notranslate">Shader</span> Language), <strong>HLSL</strong> (High-level <span class="notranslate">Shader</span> Language, używany podczas pracy z DirectX) oraz GLSL <strong>ES</strong> (podzbiór GLSL, który jest powszechny w urządzeniach mobilnych). Tutaj używamy <strong>GLSL ES</strong> jako języka <span class="notranslate">shader</span>, ponieważ jest to ten, który zapewnia najlepszą kompatybilność na platformach docelowych. Generalnie jest to ten, którego zawsze chcesz użyć, chyba że masz bardzo specyficzne potrzeby i rozumiesz ograniczenia innych języków <span class="notranslate">shader</span>. Matematyka i techniki powinny być podobne między wszystkimi trzema językami, jednak z wyjątkiem kilku różnic w składni tu i tam.</p>
  <p>Program <span class="notranslate">vertex</span> <span class="notranslate">shader</span> jest wykonywany jako pierwszy i jak wyjaśniliśmy powyżej, zajmuje się on <strong>wierzchołkami</strong>. Jest on używany do obliczania pozycji, normaliów i współrzędnych <span class="notranslate">texture</span>. Te <span class="notranslate">shaders</span> nie są szczególnie przydatne w 2D, ponieważ każda <span class="notranslate">sprite</span> jest zazwyczaj kwadratem, ale można je wykorzystać do wykonania pewnych przekrzywień, skalowania, itp. Staje się to znacznie bardziej przydatne w 3D do obliczeń oświetlenia i deformacji siatki. Fragmenty <span class="notranslate">shaders</span> są o wiele bardziej interesujące i to właśnie one będą tutaj głównie omawiane, ponieważ fragment <span class="notranslate">shader</span> jest miejscem, w którym otrzymujemy informacje o naszym <span class="notranslate">textures</span> i możemy dostosować ostateczny kolor każdego piksela w naszym obrazie.</p>
  <p> </p>
  <h2>Zmienne shadera</h2>
  <p>Jeśli stworzyłeś stronę <span class="notranslate">shader</span> w <span data-keyref="GameMaker Name">GameMakerze</span>, mogłeś zauważyć następujące słowa kluczowe w domyślnym <strong>przejściu</strong> <span class="notranslate">shader</span>. Te słowa kluczowe pomagają <span class="notranslate">shader</span> zrozumieć cel i zakres każdej zmiennej:</p>
  <ul class="colour">
    <li><strong>Attribute</strong>: Są to zmienne przekazywane przez OpenGL do <strong>vertex </strong>shadera. Mogą się one zmieniać na <span class="notranslate">vertex</span> i są tylko do odczytu. Zawierają one takie informacje jak <span class="notranslate">vertex</span> position, <span class="notranslate">texture</span> coordinates, <span class="notranslate">vertex</span> color oraz <span class="notranslate">vertex</span> normal.</li>
    <li><strong>Varying</strong>: Są to zmienne używane do przekazywania danych pomiędzy shaderami <strong>wierzchołków </strong>i <strong>fragmentów </strong>. Są one dostępne do zapisu w <span class="notranslate">vertex</span> <span class="notranslate">shader</span>, ale są tylko do odczytu we fragmencie <span class="notranslate">shader</span>.</li>
    <li><strong>Uniform</strong>: Są to zmienne, które zmieniają się per <span class="notranslate">object</span> i są przekazywane przez użytkownika do <span class="notranslate">shader</span>. Mogą być używane zarówno w <span class="notranslate">vertex</span> jak i fragmencie <span class="notranslate">shaders</span>, ale są tylko do odczytu.</li>
  </ul>
  <p>Zobaczysz również użycie <strong>vec</strong> jako słowa kluczowego. Jest ono używane do identyfikacji zmiennej wektorowej w <span class="notranslate">shader</span> i wkrótce zobaczysz, że wektory są bardzo ważne podczas pracy z <span class="notranslate">shaders</span>. Dlatego też są one zaimplementowane jako typ bazowy w GLSL. Jeśli nie jesteś z nimi zaznajomiony, są one pojęciem matematycznym reprezentowanym jako macierz z tylko jedną kolumną. W programowaniu zwykle reprezentujemy je jako tablicę, gdzie liczba składowych odpowiada wymiarowi. Dwu i trójwymiarowe wektory są często używane dla pozycji, <span class="notranslate">texture</span> współrzędnych lub kolorów bez kanału alfa, podczas gdy czterowymiarowe są używane dla kolorów z kanałem alfa. Możemy również określić, czy przechowują one wartości logiczne, całkowite czy zmiennoprzecinkowe. Składnia do zadeklarowania wektora jest taka:</p>
  <p class="code">vec2 firstVec;  // Two-dimensional vector of floats<br />
    vec3 secondVec; // Three-dimensional vector of floats<br />
    vec4 thirdVec;  // Four-dimensional vector of floats<br />
    <br />
    bvec3 boolVec;  // Three-dimensional vector of booleans<br />
    ivec4 intVec;   // Four-dimensional vector of integers
  </p>
  <p>Aby je zainicjować, możemy użyć konstruktora do utworzenia wektora. Musisz podać taką samą liczbę wartości jak długość wektora, ale możesz mieszać i dopasowywać skalary i mniejsze wektory, aby osiągnąć docelową długość. Oto kilka przykładów:</p>
  <p class="code">// Simple 2D vector with 2 scalar values<br />
    vec2 firstVec  = vec2(2.0, 1.0);<br />
    // A 4D vector using 2 scalars and a vec2 create the 4 values<br />
    vec4 secondVec = vec4(1.0, firstVec, 0.0);<br />
    // A 3D vector using 1 component of a vec4 plus a vec2 to create the 3 values<br />
    vec3 thirdVec  = vec3(secondVec.x, firstVec);</p>
  <p>Możemy też przypisać im inny wektor o tej samej długości (lub <em>swizzleować </em>wektor, aż będzie miał odpowiednią długość, ale to wyjaśnimy za chwilę):</p>
  <p class="code">vec3 firstVec;<br />
    vec3 secondVec = firstVec;<br />
    vec4 thirdVec  = secondVec.xyz;<br />
    vec2 fourthVec = thirdVec.zx;</p>
  <p>Podczas dostępu do składowych wektora w GLSL, mamy kilka opcji. Najbardziej podstawową jest potraktowanie wektora jako tablicy i dostęp do składowych za pomocą nawiasów kwadratowych, tak jak to:</p>
  <p class="code">vec4 myVec;<br />
    myVec[0] = 1.0;<br />
    myVec[1] = 0.0;<br />
    myVec[2] = 2.0;<br />
    myVec[3] = 1.0;</p>
  <p>Istnieje jednak inny sposób dostępu do komponentów z następującą składnią:</p>
  <p class="code">vec4 myVec;<br />
    myVec.x = 1.0;<br />
    myVec.y = 2.0;</p>
  <p>Używa to nazw składowych wewnątrz wektora, aby uzyskać do nich dostęp. Możesz użyć x, y, z lub w, aby uzyskać odpowiednio pierwszą, drugą, trzecią lub czwartą składową. Określamy tę metodę jako <strong>swizzling </strong>, ponieważ następująca składnia jest również poprawna:</p>
  <p class="code">vec4 firstVec;<br />
    vec3 secondVec = firstVec.xyz;<br />
    vec2 thirdVec  = secondVec.zy;<br />
    vec4 fourthVec = thirdVec.yxxy;</p>
  <p>Jak widać, możemy użyć dowolnej kombinacji do czterech liter, aby stworzyć wektor o tej długości. Nie możemy próbować uzyskać dostępu do składowej, która byłaby poza granicami (na przykład, próbując uzyskać dostęp do w w <span class="inline">secondVec</span> lub <span class="inline">thirdVec</span>, ponieważ nie mają one czwartej składowej). Możemy również powtarzać litery i używać ich w dowolnej kolejności, o ile zmienna wektorowa, do której jest przypisana, ma taki sam rozmiar jak liczba użytych liter.</p>
  <p>Z oczywistych powodów, kiedy używasz swizzle do ustawiania wartości komponentów, nie możesz użyć tego samego komponentu dwa razy. Na przykład poniższe nie jest poprawne, ponieważ próbujesz ustawić ten sam komponent na dwie różne wartości:</p>
  <p class="code">myVec.xx = vec2(2.0, 3.0);</p>
  <p>Ostatnio używaliśmy <span class="inline">xyzw</span> jako naszej maski swizzle, co zwykle ma miejsce, gdy mamy do czynienia z pozycjami. Istnieją jeszcze dwa zestawy masek, których możesz użyć: <span class="inline">rgba</span> (używany dla kolorów), lub <span class="inline">stpq</span> (używany dla współrzędnych <span class="notranslate">texture</span> ). Wewnętrznie nie ma różnicy między tymi maskami, a używamy ich tylko po to, aby kod był bardziej przejrzysty, co reprezentuje wektor w danym przypadku. Ponadto nie możemy łączyć masek swizzle w tej samej operacji, więc jest to nieważne:</p>
  <p class="code"><span class="inline"></span>myVec = otherVec.ybp;</p>
  <p>To było dużo definicji i informacji, ale znajomość tych rzeczy jest niezbędna do zrozumienia samego <span class="notranslate">shaders</span>.</p>
  <p> </p>
  <h2>Tworzenie shadera</h2>
  <p>Kiedy tworzysz <span class="notranslate">shader</span> w <span data-keyref="GameMaker Name">GameMakerze</span>, otworzy on dla Ciebie dwa pliki: <span class="notranslate">vertex</span> <span class="notranslate">shader</span> (<span class="inline">.vsh</span>) i fragment <span class="notranslate">shader</span> (<span class="inline">.fsh</span>). Jest to najbardziej podstawowy <span class="notranslate">shader</span> jaki możesz stworzyć, który pobiera <span class="notranslate">sprite</span>, czyta <span class="notranslate">texture</span> i koloruje każdy piksel tym kolorem. Jeśli podczas rysowania określisz kolory <span class="notranslate">vertex</span>, kolory te zmieszają się z <span class="notranslate">texture</span>.</p>
  <p>Przejdźmy przez kod dla nowo utworzonego <span class="notranslate">shader</span> <span class="notranslate">asset</span> i przeanalizujmy go, zaczynając od <span class="notranslate">vertex</span> <span class="notranslate">shader</span>.</p>
  <p class="code">// Passthrough Vertex Shader<br />
    attribute vec3 in_Position;                  // (x,y,z)<br />
    //attribute vec3 in_Normal;                  // (x,y,z)     unused in this shader.<br />
    attribute vec4 in_Colour;                    // (r,g,b,a)<br />
    attribute vec2 in_TextureCoord;              // (u,v)<br />
    <br />
    varying vec2 v_vTexcoord;<br />
    varying vec4 v_vColour;<br />
    <br />
    void main()<br />
    {<br />
        vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);<br />
        gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;<br />
        <br />
        v_vColour = in_Colour;<br />
        v_vTexcoord = in_TextureCoord;<br />
    }
  </p>
  <p>Poza funkcją główną widzimy kilka deklaracji zmiennych i ich kwalifikatorów. Atrybuty są nam dane przez <span class="notranslate">GameMaker</span>. Zmienne są tworzone przez użytkownika, aby przekazać tę informację do fragmentu <span class="notranslate">shader</span>. Wewnątrz głównej funkcji mamy obliczenia, które mają na celu znalezienie pozycji wierzchołka na ekranie:</p>
  <ul class="colour">
    <li>Najpierw tworzymy stronę <span class="inline">vec4</span> i inicjalizujemy ją składowymi pozycji, dodając jeden jako czwartą składową. W algebrze liniowej konwencja jest taka, że dodajemy jedynkę do czwartej składowej, jeśli wektor reprezentuje punkt, lub zero, jeśli reprezentuje rzeczywisty wektor.</li>
    <li>Następnie musimy dodać ten czwarty składnik, aby pomnożyć go z macierzą <span class="inline">MATRIX_WORLD_VIEW_PROJECTION</span>, która jest macierzą 4x4. To mnożenie spowoduje rzutowanie pozycji światowej <span class="notranslate">vertex</span> na współrzędne ekranowe.</li>
    <li>Na koniec przekazujemy kolor <span class="notranslate">vertex</span> i współrzędne <span class="notranslate">texture</span> do fragmentu <span class="notranslate">shader</span> poprzez nasze zmienne varying.</li>
  </ul>
  <p>Ten <span class="notranslate">shader</span> należy zostawić w spokoju, jeśli nie planujesz bawić się pozycjami <span class="notranslate">vertex</span> i nie będzie on używany w żadnym z podanych poniżej przykładów, ponieważ wszystkie pokazane efekty zostaną stworzone przy użyciu fragmentu <span class="notranslate">shader</span>.</p>
  <p>Przyjrzyjmy się teraz szybko fragmentowi <span class="notranslate">shader</span>:</p>
  <p class="code">// Passthrough Fragment Shader<br />
    varying vec2 v_vTexcoord;<br />
    varying vec4 v_vColour;<br />
    <br />
    void main()<br />
    {<br />
        gl_FragColor = v_vColour * texture2D( gm_BaseTexture, v_vTexcoord );<br />
    }
  </p>
  <p>Jak wyjaśniono wcześniej, ideą fragmentu <span class="notranslate">shader</span> jest zwrócenie koloru bieżącego piksela. Odbywa się to poprzez przypisanie zmiennej <span class="inline">gl_FragColor</span> ostatecznej wartości koloru. Funkcja <span class="inline">texture2D</span> pobiera <span class="notranslate">texture</span> i <span class="inline">vec2</span> ze współrzędnymi UV, które chcesz sprawdzić w tym <span class="notranslate">texture</span>, który zwraca <span class="inline">vec4</span> z kolorem. W przejściu przez <span class="notranslate">shader</span>, wszystko co robimy to złapanie koloru <span class="notranslate">texture</span> we współrzędnej tego piksela i pomnożenie go przez kolor <span class="notranslate">vertex</span> związanego z tym pikselem.</p>
  <p>Teraz, gdy mamy nasz pierwszy <span class="notranslate">shader</span>, wszystko co musimy zrobić, aby go przetestować, to stworzyć <span class="notranslate">object</span> i przypisać mu <span class="notranslate">sprite</span>, a następnie w <strong>zdarzeniu Draw Event</strong> z <span class="notranslate">object</span> ustawić <span class="notranslate">shader</span> w taki sposób:</p>
  <p class="code">// Draw Event<br />
    shader_set(shdrColorOverlay);<br />
    draw_self();<br />
    shader_reset();</p>
  <p>Każde wezwanie do losowania, które wykonujemy pomiędzy <a href="../GameMaker_Language/GML_Reference/Asset_Management/Shaders/shader_set.htm"><span class="inline">shader_set()</span></a> a <a href="../GameMaker_Language/GML_Reference/Asset_Management/Shaders/shader_reset.htm"><span class="inline">shader_reset()</span></a> będzie miało zastosowany <span class="notranslate">shader</span>. Tutaj rysujemy stronę <span class="notranslate">object</span> <span class="notranslate">sprite</span> za pomocą naszego passthrough shadera:</p>
  <p><img>Jak można się domyślić, nie zmienia to wizualnie niczego, ponieważ jest to prosty pass-through <span class="notranslate">shader</span>. Jednakże sekcje poniżej przedstawiają kilka prostych kroków, które możesz podjąć, aby zmodyfikować to i zmienić sposób, w jaki <span class="notranslate">sprite</span> będzie rysowany. Każda z sekcji pokazuje inny <span class="notranslate">shader</span>, który możesz stworzyć i wykorzystać w swoich projektach, wyjaśniając kroki wymagane do ich stworzenia i dlaczego robimy rzeczy w ten sposób.</p>
  <p> </p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#">Nakładanie kolorów Shader</a></p>
  <div class="droptext" data-targetname="drop-down">
    <p class="dropspot">Możemy teraz edytować bazę <span class="notranslate">shader</span>, aby zrobić coś innego. Nie będziemy dotykać części <span class="notranslate">vertex</span> <span class="notranslate">shader</span>, a jedynie edytować fragment <span class="notranslate">shader</span>, a na początek wykonamy bardzo prostą operację, polegającą na tym, że <span class="notranslate">shader</span> narysuje <span class="notranslate">sprite</span> używając koloru czerwonego. Zrobimy to, zmieniając po prostu fragment <span class="inline">gl_FragColor</span> na czerwony, w taki sposób:</p>
    <p class="code">// Color Overlay Fragment Shader<br />
      void main()<br />
      {<br />
          gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);<br />
      }</p>
    <p class="dropspot">Da nam to następujący wynik:</p>
    <p class="dropspot"><img>Nie jest to dokładnie to, czego się spodziewaliśmy! Musimy pamiętać, że każdy <span class="notranslate">sprite</span> jest ostatecznie prostokątem, więc jeśli nie uwzględnimy przezroczystości - czego nie zrobiliśmy - taki wynik otrzymamy.</p>
    <p class="note"><strong>UWAGA</strong>: Na powyższym obrazku prostokąt zmienia rozmiar, ponieważ podstawa <span class="notranslate">sprite</span> miała &quot;pustą&quot; przestrzeń wokół siebie przyciętą automatycznie, gdy została umieszczona na stronie <span class="notranslate">texture</span> przez <span class="notranslate">GameMaker</span>, więc w każdej klatce animacji tworzące ją trójkąty mają inne rozmiary, aby dopasować się do przyciętego rozmiaru ramki. Jeśli wyłączysz tę opcję, będziesz miał po prostu nieruchomy czerwony kwadrat na ekranie.</p>
    <p class="dropspot">Powyżej wspomnieliśmy o funkcji <span class="inline">texture2D</span> i użyjemy jej do złapania koloru przy pikselu, nad którym pracujemy, i uzyskania z niego przezroczystości. Wartością zwrotną funkcji <span class="inline">texture2D</span> jest <span class="inline">vec4</span>, gdzie składowe to czerwony, zielony, niebieski i alfa, w tej kolejności. Dostęp do kanału alfa możemy uzyskać poprzez postawienie kropki, a następnie <span class="inline">a</span> lub <span class="inline">w</span> po nazwie zmiennej. Odpowiada to odpowiednio RGBA i XYZW.</p>
    <p class="dropspot">Oto zaktualizowany kod:</p>
    <p class="code">// Color Overlay Fragment Shader<br />
      varying vec2 v_vTexcoord;<br />
      <br />
      void main()<br />
      {<br />
          vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);<br />
          gl_FragColor = vec4(1.0, 0.0, 0.0, texColor.a);<br />
      }
    </p>
    <p class="dropspot">Teraz przypisujemy nowy <span class="inline">vec4</span> do <span class="inline">gl_FragColor</span>, gdzie kanał czerwony jest maksymalny, kanały zielony i niebieski są zerowe, a kanał alfa jest taki sam jak oryginalny <span class="notranslate">texture</span>. Dane wyjściowe wyglądają tak:</p>
    <p class="dropspot"><img>Teraz to jest to, o co nam chodziło! Zamieniliśmy kolor każdego piksela na czerwony, ale zachowaliśmy nienaruszony kanał alfa.</p>
    <p class="dropspot">Konieczność zmiany <span class="notranslate">shader</span> za każdym razem, gdy chcemy użyć innego koloru, nie jest dobrym pomysłem, zwłaszcza że musielibyśmy mieć osobny <span class="notranslate">shader</span> dla każdego koloru, który chcemy. Zamiast tego, przekażemy informacje o kolorze do <span class="notranslate">shader</span> używając <strong>uniformu</strong>. Aby to zrobić, musimy najpierw uzyskać <strong>wskaźnik </strong>do uniformu. Zrobimy to w <strong>zdarzeniu Create</strong> naszego <span class="notranslate">object</span>, które posiada <span class="notranslate">sprite</span>, dodając:</p>
    <p class="code">// Create Event<br />
      _uniColor = shader_get_uniform(shdrColorOverlay, &quot;u_colour&quot;);<br />
      _color    = [1.0, 1.0, 0.0, 1.0];</p>
    <p class="dropspot">Wszystko, co musimy zrobić, to wywołać <a href="../GameMaker_Language/GML_Reference/Asset_Management/Shaders/shader_get_uniform.htm"><span class="inline">shader_get_uniform()</span></a> aby otrzymać wskaźnik do uniformu. Parametry, które musimy przekazać to nazwa <span class="notranslate">shader</span> <span class="notranslate">asset</span> (bez cudzysłowu, ponieważ chcemy przekazać identyfikator, który wygeneruje dla nas <span class="notranslate">GameMaker</span> ) oraz nazwa zmiennej uniformu wewnątrz <span class="notranslate">shader</span>, tym razem jako <span class="notranslate">string</span>. Ta nazwa musi dokładnie odpowiadać tej wewnątrz kodu <span class="notranslate">shader</span>, aby to zadziałało. Dodaliśmy również zmienną koloru, abyśmy mogli ją zmienić na stronie <span class="notranslate">runtime</span> i aby zapamiętała nasze zmiany.</p>
    <p class="dropspot">Teraz kod w naszym zdarzeniu draw zmieni się nieco, aby przekazać zmienną uniform.</p>
    <p class="code">// Draw Event<br />
      shader_set(shdrColorOverlay);<br />
      shader_set_uniform_f_array(_uniColor, _color);<br />
      draw_self();<br />
      shader_reset();</p>
    <p class="dropspot">Jest to ten sam kod co wcześniej, ale zanim cokolwiek narysujemy, musimy przekazać wszystkie wartości uniformu do <span class="notranslate">shader</span>. W tym przypadku przekazujemy kolor jako tablicę floats. Jeśli chodzi o <span class="notranslate">shader</span>, zmienimy go, aby uwzględnić mundur i użyć go, więc staje się:</p>
    <p class="code">// Color Overlay Fragment Shader<br />
      varying vec2 v_vTexcoord;<br />
      uniform vec4 u_color;<br />
      void main()<br />
      {<br />
          vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);<br />
          gl_FragColor = vec4(u_color.rgb, texColor.a);<br />
      }</p>
    <p class="dropspot">Deklarujemy zmienną o tej samej nazwie co w create <span class="notranslate">shader</span> (<span class="inline">u_color</span>) i przekazujemy ją jako pierwsze trzy składowe wektora <span class="inline">gl_FragColor</span>, korzystając ze swizzlingu. Jeśli skompilujemy ponownie, powinniśmy zobaczyć to:</p>
    <p class="dropspot"><img>Teraz <span class="notranslate">shader</span> jest znacznie bardziej użyteczny i wielokrotnego użytku. Od ciebie zależy, czy dodasz więcej funkcjonalności, jeśli potrzebujesz jej do ustawienia koloru (za pomocą zmiennej <span class="inline">_color</span>) podczas <span class="notranslate">runtime</span>.</p>
    <p> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">Black And White Shader</a></p>
  <div class="droptext" data-targetname="drop-down1">
    <p class="dropspot">Tworzenie czarno-białej <span class="notranslate">shader</span> to świetny sposób, aby dowiedzieć się więcej o tym, jak działa <span class="notranslate">shaders</span>, a wielu początkujących zaczyna od próby zrobienia tego, ponieważ koncepcyjnie jest to dość proste: zdobądź każdy piksel i przypisz mu odcień szarości. Ale czy to jest proste? Nie do końca...</p>
    <p class="dropspot">Podczas korzystania z koloru RGB, jeśli wszystkie trzy składowe mają tę samą wartość, to otrzymujemy tonację szarą. Naiwne podejście do tworzenia <span class="notranslate">shader</span> w celu wykorzystania tego pomysłu polegałoby na dodaniu wszystkich trzech kanałów koloru (czerwonego, zielonego i niebieskiego), a następnie podzieleniu tego przez trzy. Po tym przypisałbyś wartość do wszystkich trzech kanałów, tworząc w ten sposób ton szary. Oto jak wygląda taki fragment <span class="notranslate">shader</span>:</p>
    <p class="code">// Black and white fragment shader<br />
      varying vec2 v_vTexcoord;<br />
      varying vec4 v_vColour;<br />
      <br />
      void main()<br />
      {<br />
          vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);<br />
          float gray = (texColor.r + texColor.g + texColor.b) / 3.0;<br />
          gl_FragColor = v_vColour * vec4(gray, gray, gray, texColor.a);<br />
      }
    </p>
    <p class="dropspot">Jedną z rzeczy, którą mogłeś zauważyć, jest to, że w kodzie <span class="inline">gl_FragColor</span> mnożymy <span class="inline">vec4</span> z czymś zwanym <span class="inline">v_vColour</span>. Jest to zmienna przekazywana przez <span class="notranslate">vertex</span> <span class="notranslate">shader</span>, która mówi nam o kolorze <span class="notranslate">vertex</span> związanym z tym pikselem. Zawsze warto pomnożyć swój ostatecznie obliczony kolor przez kolor <span class="notranslate">vertex</span>. W większości przypadków to nic nie da, ale jeśli zmieniłeś kolor <span class="notranslate">vertex</span> w <span class="notranslate">GML</span>, to będzie to odzwierciedlone (poprzez użycie funkcji takich jak <a href="../GameMaker_Language/GML_Reference/Drawing/Sprites_And_Tiles/draw_sprite_ext.htm"><span class="inline">draw_sprite_ext()</span></a> lub <a href="../GameMaker_Language/GML_Reference/Drawing/Sprites_And_Tiles/draw_sprite_general.htm"><span class="inline">draw_sprite_general()</span></a> aby zmienić <a href="../GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Instance_Variables/image_blend.htm"><span class="inline">image_blend</span></a>).</p>
    <p class="dropspot">Jeśli chodzi o zdarzenie losowania, to jest ono dość proste, ponieważ nie mamy uniformu do przekazania:</p>
    <p class="code">// Draw Event<br />
      shader_set(shdrBlackAndWhite);<br />
      draw_self();<br />
      shader_reset();</p>
    <p class="dropspot">Skompilujmy i zobaczmy, co uzyskaliśmy.</p>
    <p class="dropspot"><img>To już wygląda świetnie, prawda? Cóż, tak i nie... istnieje rozwiązanie, które jest bardziej "poprawne", ponieważ zamiast dodawać składowe i dzielić przez trzy, mnożymy każdą składową przez standardowe wartości NTSC dla czerni i bieli. Oto zmodyfikowany fragment <span class="notranslate">shader</span> kodu:</p>
    <p class="code">// Black and white fragment shader<br />
      varying vec2 v_vTexcoord;<br />
      <br />
      void main()<br />
      {<br />
          vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);<br />
          float gray = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));<br />
          gl_FragColor = vec4(gray, gray, gray, texColor.a);<br />
      }
    </p>
    <p class="dropspot">Iloczynu kropkowego używamy jako skrótu do pomnożenia każdego składnika <span class="inline">texColor</span> z odpowiednimi wagami, a następnie dodania ich razem. Jeśli nie jesteś zaznajomiony z produktem kropkowym, to jest to zasadniczo to, co się dzieje:</p>
    <p class="code">float gray = (texColor.r * 0.299) + (texColor.g * 0.587) + (texColor.b * 0.114);</p>
    <p class="dropspot">W końcu wygląda to bardzo podobnie, ale jest technicznie bardziej poprawne.</p>
    <p class="dropspot"><img alt="Shader Vertices" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_Vertices.gif" /></p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#">Shader tęczy</a></p>
  <div class="droptext" data-targetname="drop-down2">
    <p class="dropspot">Nasz ostatni przykład <span class="notranslate">shader</span> jest zabawny i może być użyty do dodania życia do tekstu, przycisków i innych rzeczy. Zaczniemy prosto i będziemy dodawać funkcjonalność stopniowo, ponieważ ten <span class="notranslate">shader</span> jest bardzo konfigurowalny. Jest dość dużo do omówienia, więc jeśli czujesz się zagubiony lub zdezorientowany, wróć i przeczytaj ponownie niektóre z powyższych sekcji.</p>
    <p class="dropspot">Pierwszą rzeczą, którą chcemy zrobić, jest pokolorowanie pikseli z każdym odcieniem, w zależności od pozycji poziomej piksela. Sposobem na to jest ustawienie pozycji x jako odcienia, a następnie konwersja z formatu HSV (barwa, nasycenie, jasność) do formatu RGB (czerwony, zielony i niebieski). W tym celu będziemy musieli napisać funkcję pomocniczą w naszym fragmencie <span class="notranslate">shader</span>, która przyjmuje wartości HSV i zwraca wektor RGB. Użyjemy pojedynczej funkcji, która zrobi to bez potrzeby używania jakichkolwiek <span class="inline">if</span> deklaracji, ponieważ używanie warunkowości w kodzie <span class="notranslate">shader</span> sprawia, że <span class="notranslate">shaders</span> jest <em>bardzo </em>powolny i należy go unikać.</p>
    <p class="dropspot">Oto jak wygląda <span class="notranslate">shader</span> na tym etapie:</p>
    <p class="code">// Fragment Shader<br />
      varying vec2 v_vTexcoord;<br />
      varying vec4 v_vColour;<br />
      <br />
      vec3 hsv2rgb(vec3 c) <br />
      {<br />
          vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);<br />
          vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);<br />
          return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);<br />
      }<br />
      <br />
      void main()<br />
      {<br />
          vec3 col = vec3(v_vTexcoord.x, 1.0, 1.0);<br />
          float alpha = texture2D(gm_BaseTexture, v_vTexcoord).a;<br />
          gl_FragColor = v_vColour * vec4(hsv2rgb(col), alpha);<br />
      }
    </p>
    <p class="dropspot">Dzieje się tu trochę więcej niż w poprzednich przykładach, ale większość z nich powinna być już dla Ciebie dość oczywista. Po pierwsze, jest nasza funkcja <span class="inline">hsv2rgb</span>, która pobiera <span class="inline">vec3</span> z naszym kolorem HSV i zwraca inny <span class="inline">vec3</span> z naszą konwersją RGB. W głównej funkcji zaczynamy od stworzenia naszego koloru HSV, gdzie barwa jest naszą pozycją x, a nasycenie i jasność pozostawimy na razie jako 1.0. Następnie pobieramy alfę z <span class="notranslate">texture</span>, aby pokolorować tylko naszą postać <span class="notranslate">sprite</span>, a nie cały prostokąt <span class="notranslate">sprite</span> (jak to zrobiliśmy w przykładzie z nakładaniem kolorów, powyżej). Na koniec ustawiamy nasz kolor Fragmentu jako nasz kolor HSV zamieniony na RGB z alfą, pomnożony przez kolor <span class="notranslate">vertex</span> (dobrą praktyką jest robienie tego zawsze).</p>
    <p class="dropspot">Jeśli chodzi o nasz kod losowania, to w tej chwili jest on banalny:</p>
    <p class="code">// Draw Event<br />
      shader_set(shdrRainbow);<br />
      draw_self();<br />
      shader_reset();</p>
    <p class="dropspot">Sprawdźmy, co udało nam się uzyskać:</p>
    <p class="dropspot"><img>Jesteśmy blisko tego, co chcemy, ale jest pewien problem: nie widzimy wszystkich kolorów jednocześnie w każdej klatce animacji, a kolory wydają się zmieniać losowo. Powodem tego jest to, że założyliśmy, iż <span class="inline">v_vTexcoord</span> podał nam współrzędne <span class="notranslate">sprite</span>, zaczynając od lewego górnego rogu (0,0) i kończąc w prawym dolnym rogu (1,1), co jest standardem w <span class="notranslate">shaders</span>. Jednakże, dla optymalizacji, <span class="notranslate">GameMaker</span> upycha tyle <span class="notranslate">textures</span> ile może zmieścić się w tak zwanej <a href="../Settings/Texture_Information/Texture_Pages.htm">stronie tekstury</a>, i z tego powodu tak właśnie wygląda nasz <span class="notranslate">texture</span>:</p>
    <p class="dropspot"><img>Jak wyjaśniono powyżej, <span class="inline">v_vTexcoord</span> daje nam bezwzględne współrzędne <span class="notranslate">sprite</span> w obrębie całej strony <span class="notranslate">texture</span>, ale to, czego chcemy, to wartość od 0,0 do 1,0, która obejmuje tylko naszą bieżącą stronę <span class="notranslate">sprite</span>. Ten proces nazywa się <strong>normalizacją</strong> (uzyskanie wartości i przetłumaczenie jej na zakres od 0 do 1). Aby znormalizować nasze wartości poziome, musimy znać wartości x0 i x1 na powyższym obrazku. Na szczęście <span class="notranslate">GameMaker</span> ma funkcję, która daje nam położenie każdego rogu w naszym <span class="notranslate">sprite</span> w obrębie strony <span class="notranslate">texture</span>. Najpierw musimy przejść do Create Event i stworzyć uniform, który przekaże te dane do shadera:</p>
    <p class="code">// Create Event<br />
      _uniUV = shader_get_uniform(shdrRainbow, &quot;u_uv&quot;);</p>
    <p class="dropspot">I modyfikujemy zdarzenie draw, aby uzyskać wartości, a następnie przekazać je do shadera:</p>
    <p class="code">// Draw Event<br />
      shader_set(shdrRainbow);<br />
      var uv = sprite_get_uvs(sprite_index, image_index);<br />
      shader_set_uniform_f(_uniUV, uv[0], uv[2]);<br />
      draw_self();<br />
      shader_reset();</p>
    <p class="dropspot">Funkcja <a href="../GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Information/sprite_get_uvs.htm"><span class="inline">sprite_get_uvs()</span></a> przyjmuje adres <span class="notranslate">sprite</span> oraz indeks i zwraca tablicę z mnóstwem informacji, takich jak współrzędne każdego rogu, ile pikseli zostało przyciętych w celu optymalizacji, itp. Nas interesują dwie z tych wartości: współrzędne lewego i prawego narożnika <span class="notranslate">sprite</span>, które są przechowywane odpowiednio w <span class="inline">uv[0]</span> i <span class="inline">uv[2]</span>. We fragmencie <span class="notranslate">shader</span>, użyjemy teraz tych wartości do obliczenia znormalizowanej pozycji poziomej w ten sposób:</p>
    <p class="code">// Fragment Shader<br />
      varying vec2 v_vTexcoord;<br />
      varying vec4 v_vColour;<br />
      <br />
      uniform vec2 u_uv;<br />
      <br />
      vec3 hsv2rgb(vec3 c) <br />
      {<br />
          vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);<br />
          vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);<br />
          return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);<br />
      }<br />
      <br />
      void main()<br />
      {<br />
          float pos = (v_vTexcoord.x - u_uv[0]) / (u_uv[1] - u_uv[0]);<br />
          vec3 col = vec3(pos, 1.0, 1.0);<br />
          float alpha = texture2D(gm_BaseTexture, v_vTexcoord).a;<br />
          gl_FragColor = v_vColour * vec4(hsv2rgb(col), alpha);<br />
      }
    </p>
    <p class="dropspot">Tutaj dodajemy zmienną uniform na górze pliku o tej samej nazwie, której użyliśmy w zdarzeniu Create. Następnie obliczamy znormalizowaną pozycję poziomą, tłumacząc naszą bieżącą współrzędną <span class="inline">x</span> na oryginał ( <span class="inline">v_vTexcoord.x - u_uv[0]</span>), a następnie dzielimy ją przez szerokość <span class="notranslate">sprite</span>, aby uzyskać zakres od 0 do 1 (<span class="inline">u_uv[1] - u_uv[0]</span>).</p>
    <p class="dropspot">Wynika z tego, że:</p>
    <p class="dropspot"><img>No i proszę! To jest dokładnie to, czego chcieliśmy. Możemy zobaczyć każdy kolor widma wewnątrz naszego <span class="notranslate">sprite</span>.</p>
    <p class="dropspot">Możesz być z tego zadowolony, ale możemy mieć trochę więcej zabawy z tym <span class="notranslate">shader</span>. Co by było, gdybyśmy dodali przesunięcie do kolorów opartych wokół czasu, aby wytworzyć ruch? Aby to zrobić, będziemy potrzebować dwóch dodatkowych zmiennych dla <strong>prędkości </strong>i <strong>czasu</strong>. Będziemy również potrzebować dwóch kolejnych mundurów, po jednym dla każdej z nowych zmiennych, więc zdarzenie Create staje się:</p>
    <p class="code">// Create Event<br />
      _uniUV    = shader_get_uniform(shdrRainbow, &quot;u_uv&quot;);<br />
      _uniTime  = shader_get_uniform(shdrRainbow, &quot;u_time&quot;);<br />
      _uniSpeed = shader_get_uniform(shdrRainbow, &quot;u_speed&quot;);<br />
      _time  = 0;<br />
      _speed = 1.0;</p>
    <p class="dropspot">Potrzebujemy też zwiększać czas co klatkę, więc w Step Event dodajemy:</p>
    <p class="code">// Step Event<br />
      _time += 1 / room_speed;</p>
    <p class="dropspot">Przejdźmy teraz do zdarzenia draw, aby wysłać te uniformy do shadera:</p>
    <p class="code">// Draw Event<br />
      shader_set(shdrRainbow);<br />
      var uv = sprite_get_uvs(sprite_index, image_index);<br />
      shader_set_uniform_f(_uniUV, uv[0], uv[2]);<br />
      shader_set_uniform_f(_uniSpeed, _speed);<br />
      shader_set_uniform_f(_uniTime, _time);<br />
      draw_self();<br />
      shader_reset();</p>
    <p class="dropspot">Na koniec wrócimy do naszej strony <span class="notranslate">shader</span>, aby faktycznie użyć tych zmiennych teraz. To co zrobimy to pomnożenie prędkości przez czas i dodanie tego do pozycji, w taki sposób:</p>
    <p class="code">// Fragment Shader<br />
      varying vec2 v_vTexcoord;<br />
      varying vec4 v_vColour;<br />
      <br />
      uniform vec2 u_uv;<br />
      uniform float u_speed;<br />
      uniform float u_time;<br />
      <br />
      vec3 hsv2rgb(vec3 c) <br />
      {<br />
          vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);<br />
        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);<br />
          return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);<br />
      }<br />
      <br />
      void main()<br />
      {<br />
          float pos = (v_vTexcoord.x - u_uv[0]) / (u_uv[1] - u_uv[0]);<br />
          vec3 col = vec3((u_time * u_speed) + pos, 1.0, 1.0);<br />
          float alpha = texture2D(gm_BaseTexture, v_vTexcoord).a;<br />
          gl_FragColor = v_vColour * vec4(hsv2rgb(col), alpha);<br />
      }
    </p>
    <p class="dropspot">Jeśli zrobiłeś wszystko poprawnie, powinieneś zobaczyć coś takiego:</p>
    <p class="dropspot"><img>Aby zakończyć ten <span class="notranslate">shader</span>, dodamy jeszcze kilka uniformów, aby jeszcze bardziej go dostosować. Pierwsze dwa mają za zadanie kontrolować nasycenie i jasność. Następny nazwiemy &quot;section&quot;, a jego funkcją jest umożliwienie użytkownikowi przekazania liczby z przedziału od zera do jednego, aby określić, jaki procent całego spektrum widzimy w danym momencie. Na koniec dodamy zmienną o nazwie &quot;mix&quot;, która określi, jak bardzo chcemy wymieszać nasz kolor <span class="notranslate">shader</span> z oryginalnym kolorem <span class="notranslate">texture</span> (1.0 to cała tęcza, 0.0 to cała <span class="notranslate">texture</span>). Jak zawsze, zacznijmy od dodania zmiennych do zdarzenia Create:</p>
    <p class="code">// Create Event<br />
      _uniUV         = shader_get_uniform(shdrRainbow, &quot;u_uv&quot;);<br />
      _uniTime       = shader_get_uniform(shdrRainbow, &quot;u_time&quot;);<br />
      _uniSpeed      = shader_get_uniform(shdrRainbow, &quot;u_speed&quot;);<br />
      _uniSection    = shader_get_uniform(shdrRainbow, &quot;u_section&quot;);<br />
      _uniSaturation = shader_get_uniform(shdrRainbow, &quot;u_saturation&quot;); <br />
      _uniBrightness = shader_get_uniform(shdrRainbow, &quot;u_brightness&quot;);<br />
      _uniMix        = shader_get_uniform(shdrRainbow, &quot;u_mix&quot;);<br />
      <br />
      _time  = 0;<br />
      _speed = 1.0;<br />
      _section = 0.5;<br />
      _saturation = 0.7;<br />
      _brightness = 0.8;<br />
      _mix = 0.5;
    </p>
    <p class="dropspot">Nasze zdarzenie losowania zmienia się tak, że obejmuje te mundury jak:</p>
    <p class="code">// Draw Event<br />
      shader_set(shdrRainbow);<br />
      var uv = sprite_get_uvs(sprite_index, image_index);<br />
      shader_set_uniform_f(_uniUV, uv[0], uv[2]);<br />
      shader_set_uniform_f(_uniSpeed, _speed);<br />
      shader_set_uniform_f(_uniTime, _time);<br />
      shader_set_uniform_f(_uniSaturation, _saturation);<br />
      shader_set_uniform_f(_uniBrightness, _brightness);<br />
      shader_set_uniform_f(_uniSection, _section);<br />
      shader_set_uniform_f(_uniMix, _mix);<br />
      draw_self();<br />
      shader_reset();</p>
    <p class="dropspot">Jeśli chodzi o <span class="notranslate">shader</span>, musimy przekazać nasycenie i jasność do koloru, co wpłynie na kolor generowany przez naszą funkcję pomocniczą. Sekcja musi być pomnożona przez naszą pozycję, aby zmniejszyć zakres. Chwycimy również cały kolor <span class="notranslate">texture</span>, dzięki czemu będziemy mogli obliczyć nasz ostateczny kolor poprzez zmieszanie koloru <span class="notranslate">texture</span> z konwersją RGB naszego koloru. Ostatni parametr funkcji mix określa, ile drugiego koloru chcemy dodać. To jest nasz ostateczny kod <span class="notranslate">shader</span>:</p>
    <p class="code">// Fragment Shader<br />
      varying vec2 v_vTexcoord;<br />
      varying vec4 v_vColour;<br />
      <br />
      uniform vec2 u_uv;<br />
      uniform float u_speed;<br />
      uniform float u_time;<br />
      uniform float u_saturation;<br />
      uniform float u_brightness;<br />
      uniform float u_section;<br />
      Uniform float u_mix;<br />
      <br />
      vec3 hsv2rgb(vec3 c) <br />
      {<br />
          vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);<br />
          vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);<br />
          return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);<br />
      }<br />
      <br />
      void main()<br />
      {<br />
          float pos = (v_vTexcoord.x - u_uv[0]) / (u_uv[1] - u_uv[0]);<br />
          vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);<br />
          <br />
          vec3 col = vec3(u_section * ((u_time * u_speed) + pos), u_saturation, u_brightness);<br />
        vec4 finalCol = mix(texColor, vec4(hsv2rgb(col), texColor.a), u_mix);<br />
          <br />
          gl_FragColor = v_vColour * finalCol;<br />
      }
    </p>
    <p class="dropspot">A nasz efekt końcowy jest taki!</p>
    <p class="dropspot"><img alt="Shader Fragments" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_Fragments.gif" /></p>
    <p class="dropspot"> </p>
  </div>
  <p> </p>
  <p>To już koniec tego krótkiego poradnika i powinieneś teraz lepiej zrozumieć, jak działa <span class="notranslate">shaders</span> i do jakich zastosowań można je wykorzystać. Powinieneś poświęcić swój czas na zabawę z <span class="notranslate">shaders</span>, który stworzyłeś zgodnie z tym przewodnikiem, i spróbować poeksperymentować z nimi w innych celach - co powiesz na stworzenie blur <span class="notranslate">shader</span>, lub <span class="notranslate">shader</span>, który tworzy monochromatyczny ekran w stylu gameboya? - ponieważ <span class="notranslate">shaders</span> są niezwykle potężnym narzędziem do dodawania wizualnej złożoności i stylu do twoich gier.</p>
  <p class="note">Chcielibyśmy podziękować <a href="https://twitter.com/AleHitti">Alejandro Hitti</a> i <strong>Amazonowi</strong> za pozwolenie na odtworzenie tego przewodnika. Oryginalną wersję można znaleźć na <a href="https://developer.amazon.com/es/blogs/appstore/post/acefafad-29ba-4f31-8dae-00805fda3f58/intro-to-shaders-and-surfaces-with-gamemaker-studio-2">Amazon Developer Blog</a>.</p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Powrót: <a href="Additional_Information.htm">Informacje dodatkowe.</a></div>
        <div style="float:right">Następny: <a href="Guide_To_Primitives_And_Vertex_Building.htm">Przewodnik po prymitywach i <span class="notranslate">Vertex</span> Budowanie</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Wszystkie prawa zastrzeżone</span></h5>
  </div>
  <!-- KEYWORDS
Shaders
Using Shaders
Shader Guide
Guide To Using Shaders
-->
  <!-- TAGS
using_shaders
-->
</body>
</html>