<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Właściwości pomieszczenia</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
  <script src="../../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page detailing the different room properties" />
  <meta name="rh-index-keywords" content="Rooms - Room Settings" />
  <meta name="search-keywords" content="room settings,cameras,viewports,room size,room properties,view cameras" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Właściwości pomieszczenia</h1>
  <p><img>W sekcji <span class="notranslate">Room</span> Properties można ustawić toggle dziedziczenia ustawień, zmienić takie opcje jak persystencja, rozmiar pokoju i zarządzać rzutniami.</p>
  <h2>Trwały</h2>
  <p>Zazwyczaj, gdy opuszczasz stronę <span class="notranslate">room</span> i wracasz do tej samej <span class="notranslate">room</span> później, ta strona <span class="notranslate">room</span> jest resetowana do swoich początkowych ustawień. Jest to zazwyczaj dobre dla większości gier, ale może nie być tym, czego oczekujesz, na przykład w grze RPG lub innej nieliniowej grze, w której chcesz wchodzić i wychodzić między <span class="notranslate">rooms</span> i mieć je w takim stanie, w jakim zostawiłeś je ostatnim razem. Zaznaczenie pola oznaczonego jako <strong>Persistent (Trwały </strong>) spowoduje właśnie to. Status <span class="notranslate">room</span> zostanie zapamiętany i kiedy wrócisz do niego później, będzie dokładnie taki sam, jak go zostawiłeś, a do stanu początkowego zostanie przywrócony dopiero po ponownym uruchomieniu gry. Zauważ, że jest <em>jeden </em>wyjątek - jeśli zaznaczyłeś pewne <span class="notranslate">objects</span> jako trwałe, instancje tego <span class="notranslate">object</span> <em>nie </em>pozostaną w <span class="notranslate">room</span>, ale przeniosą się do następnego <span class="notranslate">room</span>.</p>
  <h2 id="clear_display_buffer">Wyczyść bufor wyświetlania</h2>
  <p>Następnie masz do dyspozycji opcję <strong>Clear Display Buffer</strong>. Ta opcja, gdy jest zaznaczona, wstępnie wypełnia <a class="glossterm" data-glossterm="bufor wyświetlacza" href="#">bufor wyświetlacza</a> kolorem przed rysowaniem czegokolwiek innego dla danej klatki. Jeśli wiesz, że twoje widoki będą zajmować cały ekran przez cały czas lub masz pełnoekranowe, nieprzezroczyste tło do rysowania, możesz odznaczyć tę opcję, co zaoszczędzi ponownego rysowania i pomoże zoptymalizować grę.</p>
  <p>Jeśli jednak masz wiele widoków, które po wyświetleniu pozostawiają otwarte przestrzenie, lub twoje tło ma przezroczyste części - możesz to zaznaczyć, aby wszystkie puste obszary były wypełnione wybranym przez ciebie kolorem rysowania. Obecnie ten kolor może być ustawiony tylko poprzez kod za pomocą <a href="../../GameMaker_Language/GML_Reference/Cameras_And_Display/The_Game_Window/window_set_colour.htm"><span class="inline">window_set_colour()</span></a>.</p>
  <p class="note"><span class="note">UWAGA</span> Jeśli używasz automatycznej korekcji proporcji (ustawionej w <a href="../../Settings/Game_Options.htm">Opcjach gry</a>), to <strong>zawsze </strong>powinieneś mieć tę opcję zaznaczoną, w przeciwnym razie możesz uzyskać dziwne efekty przez &quot;letterbox&quot;, w którym gra jest rysowana. Jeśli nie używasz tej opcji, możesz ją odznaczyć i uzyskać niewielki wzrost wydajności gry (szczególnie widoczny na <span class="notranslate">Android</span> i innych platformach mobilnych).</p>
  <h2>Szerokość, wysokość i inne opcje</h2>
  <p>Strona <span class="notranslate">room</span> musi mieć rozmiar, a ten jest definiowany przez wartości, które wprowadzasz dla jej szerokości i wysokości w pikselach.</p>
  <p>Możesz wtedy dodać <strong>kod tworzenia</strong>, jeśli tego potrzebujesz. Kod tworzenia dodaje się za pomocą przycisku na dole (wraz z <span class="notranslate">inherit</span> toggle, aby powiedzieć, czy <span class="notranslate">room</span> ma <span class="notranslate">inherit</span> swój kod tworzenia czy nie), a jeśli go klikniesz, otworzysz edytor kodu lub wizualny. Edytor ten pozwala na wprowadzenie funkcji/akcji i kodu, który będzie uruchamiany na <em>początku </em> <span class="notranslate">room</span>, po zdarzeniu create wszystkich instancji, ale przed ich <span class="notranslate">room</span> zdarzeniem startowym (więcej informacji o kolejności zdarzeń znajdziesz <a href="../Object_Properties/Event_Order.htm">tutaj</a>). Ten kod będzie uruchamiany za każdym razem, gdy wejdziesz na stronę <span class="notranslate">room</span>, chyba że <span class="notranslate">room</span> jest oznaczony jako trwały, w którym to przypadku będzie uruchamiany tylko raz, gdy <span class="notranslate">room</span> jest po raz pierwszy wprowadzony, ale nie przy kolejnych wizytach na stronie <span class="notranslate">room</span>.</p>
  <h2 id="creation_order">Kolejność tworzenia instancji</h2>
  <p>Ostatni przycisk w <span class="notranslate">Room</span> Properties pozwala na otwarcie okna <strong>Instance Creation Order</strong>:</p>
  <p><img>To okno zawiera listę wszystkich instancji w <span class="notranslate">room</span> w kolejności, w jakiej zostaną utworzone (od góry do dołu). Jeśli chcesz, by konkretna instancja została utworzona przed innymi, możesz po prostu kliknąć <img> i przeciągnąć ją na żądaną pozycję. Zauważ, że instancje będą tworzone w kolejności podanej od góry do dołu listy.</p>
  <div data-conref="../../assets/snippets/Instance_creation_order_warning.hts"> </div>
  <p> </p>
  <p> </p>
  <h1>Kamery i rzutniki</h1>
  <p>Kolejnym zestawem właściwości dla <span class="notranslate">room</span>, które możesz zdefiniować, są te związane z <strong>kamerą</strong> pomieszczenia i <strong>rzutniami</strong>. Widoki z kamery dają mechanizm do rysowania różnych części twojej <span class="notranslate">room</span> w różnych miejscach ekranu, lub do rysowania tylko części <span class="notranslate">room</span>, aby pokryć cały ekran. Na przykład w większości gier platformowych widok z kamery podąża za głównym bohaterem, ponieważ gdybyś mógł zobaczyć cały poziom na ekranie, twoja postać byłaby zbyt mała, by ją zobaczyć i nie byłoby żadnych niespodzianek dla gracza. Widoki z kamery mogą być również wykorzystywane w grach dla wielu graczy lub grach kooperacyjnych, ponieważ pozwalają na stworzenie konfiguracji podzielonego ekranu, w której w jednej części ekranu widzisz jednego gracza, a w innej części widzisz drugiego gracza. To wszystko można łatwo osiągnąć w <span data-keyref="GameMaker Name">GameMakerze</span> używając widoków z kamery.</p>
  <p><img>Na górze właściwości widoku można włączyć lub wyłączyć dziedziczenie widoku, następnie znajduje się pole oznaczone jako <strong>Enable Viewports</strong>. To pole <em>musi być zaznaczone</em>, zanim którykolwiek z widoków kamery będzie mógł być użyty w Twojej grze.</p>
  <p class="note"><span class="note">UWAGA</span> Możesz włączyć lub wyłączyć dziedziczenie dla trzech głównych ustawień rzutni, a następnie możesz włączyć lub wyłączyć dziedziczenie dla każdego indywidualnego widoku z kamery.</p>
  <p>Następne pole wyboru to <strong>Clear Viewport Back</strong>ground, które jest podobne do opcji <a href="#clear_display_buffer">Clear Display Buffer</a> podanej powyżej, ale dotyczy konkretnie rzutni. Kiedy jest włączona, oczyszcza <a class="glossterm" data-glossterm="powierzchnia zastosowania" href="#">powierzchnię aplikacji</a> z koloru okna przed rysowaniem każdej klatki. Gwarantuje to, że nie zobaczysz żadnej niezamierzonej grafiki przez przezroczyste obszary tła, takie jak zawartość poprzednich klatek; dlatego ważne jest, aby włączyć tę opcję (wraz z &quot;<strong>Enable Viewports</strong>&quot;), jeśli twoje tło zawiera przezroczystość.</p>
  <p>Widok z kamery jest definiowany przez dwa różne zestawy wartości, sam widok z kamery i port na ekranie, w którym ten widok ma być rysowany. Może to czasami powodować zamieszanie, więc wyjaśnijmy to nieco przed wyjaśnieniem, jak definiujemy każdy z nich:</p>
  <ul class="colour">
    <li><strong>Camera</strong>: Punkt w obrębie <span class="notranslate">room</span>, który będzie używany do ustawienia sposobu wyświetlania <span class="notranslate">room</span> na ekranie (jest to abstrakcyjny punkt w edytorze <span class="notranslate">room</span> i jego pozycja jest ustawiana automatycznie w oparciu o ustawienia widoku i portu widoku).</li>
    <li><strong>The View</strong>: To, co widzi kamera, na podstawie pozycji, projekcji i obrotu kamery</li>
    <li><strong>Port pod</strong>glądu: obszar ekranu fizycznego, na którym będzie wyświetlany widok z kamery</li>
  </ul>
  <p><img>Tak więc, na przykład, oznacza to, że możesz mieć widok kamery 640x480 do swojego <span class="notranslate">room</span>, a następnie ustawić port na 320x240, co spowoduje wyświetlenie widoku przeskalowanego do tego rozmiaru portu na ekranie, a także możesz zrobić to samo i ustawić widok na mniejszą wartość i port na większy, co sprawi, że obraz przeskaluje się, aby dopasować rozmiar portu i zostanie wyświetlony na ekranie większy niż jest. W ten sposób można utrzymać rozmiar ekranu (portu), jednocześnie zmieniając widok kamery, aby wyświetlić więcej lub mniej <span class="notranslate">room</span> w tym samym obszarze ekranu.</p>
  <p>Widok z kamery jest zawsze definiowany jako prostokątny obszar w <span class="notranslate">room</span>, gdzie określasz pozycję lewego górnego rogu, szerokość i wysokość tego obszaru. Następnie musisz określić, gdzie ten obszar jest wyświetlany w oknie na ekranie, definiując port widoku, gdzie ponownie określasz pozycję lewego górnego rogu i rozmiar (zauważ, że wszystko inne niż 0,0 dla lewego górnego rogu może dać dziwne wyniki). Możesz mieć więcej niż jeden port i mogą one zachodzić na siebie, w takim przypadku są rysowane we wskazanej kolejności jeden na drugim.</p>
  <p>Proszę zdaj sobie sprawę, że całkowity obszar ekranu jest <em>zawsze definiowany jako obszar prost</em>okątny, tak więc twoje porty, nawet gdy są przesunięte, będą tworzyły prostokąt, z wszelkimi pustymi przestrzeniami wypełnianymi przez kolor okna <a class="glossterm" data-glossterm="bufor wyświetlacza" href="#">bufora wyświetla</a>cza, co oznacza, że w tych okolicznościach powinieneś zawsze mieć zaznaczone <strong>Clear Display Buffer</strong>, albo w przeciwnym razie będziesz miał dziwne artefakty rysowane w przestrzeniach pomiędzy portami. Obrazek poniżej ilustruje to, gdzie widoczne są dwa przesunięte porty widoku, ale tworzą one kwadratowe okno, a &quot;pod spodem&quot; są linie rysowane do bufora wyświetlacza:</p>
  <p><img>Kamery posiadają również opcję <strong>Śledzenie obiektu </strong>. Służy ona do tego, aby kamera &quot;podążała&quot; (tzn. utrzymywała widok skupiony na określonym obiekcie) <span class="notranslate">object</span>. Aby to zrobić, musisz kliknąć <img> na ikonie menu i wybrać <span class="notranslate">object</span> z listy, która się pojawi (jeśli w <span class="notranslate">object</span> jest kilka instancji tego <span class="notranslate">room</span>, tylko jedna z nich będzie śledzona przez kamerę).</p>
  <p>Normalnym zachowaniem kamery jest poruszanie się tylko wtedy, gdy śledzona postać zbytnio zbliży się do strefy &quot;buforowej&quot;, która tworzy niewidzialną granicę wokół krawędzi widoku. Strefa ta może być zdefiniowana przez Ciebie za pomocą wartości <strong>Horizontal Border </strong>i <strong>Vertical Border </strong>, więc - na przykład - ustawienie tych wartości na 64 będzie oznaczało, że widok nie zacznie się poruszać i podążać za postacią, dopóki nie osiągnie ona 64 pikseli od krawędzi widoku.</p>
  <p>Wreszcie możesz wskazać <strong>poziomą</strong> i <strong>pionową prędkość </strong>, z jaką porusza się kamera, gdy postać dotarła do strefy <span class="notranslate">buffer</span>, a ta ma domyślną wartość -1. Ta domyślna wartość jest w zasadzie &quot;natychmiastowa&quot; i oznacza, że w momencie, gdy follow instance znajdzie się poza poziomą granicą lub pionową granicą <span class="notranslate">buffer</span> strefy, widok przeskoczy do swojej bieżącej pozycji. Teraz, nie zawsze jest to to, czego chcesz, więc możesz ustawić prędkość przewijania w pionie i poziomie dla kamery, ustawiając wartości na coś innego niż -1. Zauważ, że wartość 0 spowoduje, że widok nie będzie się w ogóle poruszał, a każda inna dodatnia wartość to ilość pikseli, o jaką przesunie się w każdej klatce, więc ustawienie prędkości poziomej na 5 spowoduje, że widok będzie podążał za <span class="notranslate">object</span> z prędkością 5 pikseli na klatkę w poziomie.</p>
  <p> </p>
  <p> </p>
  <h1>Fizyka sali</h1>
  <p>Zanim będziesz mógł używać wbudowanych funkcji fizyki w swoich grach, musisz powiedzieć <span data-keyref="GameMaker Name">GameMakerowi</span>, że <span class="notranslate">room</span> jest fizyką <span class="notranslate">room</span>. Aby to zrobić, musisz zaznaczyć opcję <strong>Enable </strong>Physics na górze sekcji <em>Room Physics</em> (możesz też przełączyć dziedziczenie tej sekcji niezależnie od reszty ustawień <span class="notranslate">room</span> ). Gdy już to zrobisz, możesz przejść do ustawienia właściwości świata fizyki, czyli kilku podstawowych właściwości, które musisz mieć wstępnie zdefiniowane, zanim twoja <span class="notranslate">room</span> pozwoli instancjom fizyki działać jako takie. Aby uzyskać bardziej precyzyjną kontrolę nad światem, możesz użyć kodu (więcej informacji znajdziesz w rozdziale <a href="../../GameMaker_Language/GML_Reference/Physics/Physics.htm">Funkcje</a> fizyki).</p>
  <p><img>Następną rzeczą, którą musisz zrobić jest ustawienie <strong>Grawitacji </strong>świata. Siła i kierunek grawitacji jest obliczana jako <a class="glossterm" data-glossterm="wektor" href="#">wektor</a> pozycji x/y, którą ustawiasz wokół punktu (0, 0). Tak więc, x równe 0 i y równe 1 ustawi kierunek grawitacji na <em>dół </em>z siłą 1 metra na sekundę (bardziej szczegółowe wyjaśnienie znajdziesz w - <a href="../../GameMaker_Language/GML_Reference/Physics/The_Physics_World/The_Physics_World.htm">Świat Fizyki</a>).</p>
  <p>Na koniec musisz ustawić stosunek<strong> Pixels To Meters</strong>, aby <span data-keyref="GameMaker Name">GameMaker</span> używał go jako podstawy do wszystkich swoich obliczeń fizyki. Dzieje się tak dlatego, że funkcje fizyki działają na rzeczywistych pomiarach, dlatego musimy ustawić tę wartość, i będziesz chciał dostosować to ustawienie, aż średni rozmiar pikseli z <span class="notranslate">objects</span>, którego używasz, przełoży się z grubsza na symulację fizyki <span class="notranslate">objects</span> o odpowiedniej wielkości.</p>
  <p>Należy zauważyć, że włączenie fizyki w <span class="notranslate">room</span> oznacza, że wszystkie instancje w pomieszczeniu <em>muszą używać funkcji i zmiennych fizyki, aby się poruszać</em>. Zasadniczo masz &quot;tradycyjny&quot; ruch, gdzie możesz ustawić pozycję X/Y instancji lub ustawić jej prędkość i kierunek, a następnie masz ruch &quot;fizyki&quot;, który wymaga sił fizycznych i impulsów do poruszania się. Te systemy są <strong>wzajemnie eksluzywne</strong> i nie możesz poruszać instancji fizyki za pomocą funkcji niefizycznych i nie możesz poruszać instancji niefizycznej za pomocą funkcji fizyki.</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Powrót: <a href="../Rooms.htm">Redaktor <span class="notranslate">Room</span> </a></div>
        <div style="float:right">Następny: <a href="Room_Inheritance.htm">Dziedziczenie pomieszczeń</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Wszystkie prawa zastrzeżone</span></h5>
  </div>
  <!-- KEYWORDS
Room Properties
View Ports
View Cameras
-->
  <!-- TAGS
rooms_properties
-->
</body>
</html>