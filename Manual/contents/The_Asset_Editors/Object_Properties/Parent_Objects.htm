<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Obiekty macierzyste</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page detailing object parenting" />
  <meta name="rh-index-keywords" content="Objects - Parents" />
  <meta name="search-keywords" content="parent,child,inheritance,object parenting" />
  <link rel="stylesheet" type="text/css" href="../../assets/css/default.css" />
  <script src="../../assets/scripts/main_script.js"></script>
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Obiekty macierzyste</h1>
  <p>Podczas pracy z <span class="notranslate">objects</span> w programie <span data-keyref="GameMaker Name">GameMaker</span> <span class="notranslate">IDE</span> można tworzyć hierarchie <strong>rodzic / </strong> dziecko. Robi się to klikając przycisk &quot;Parent&quot; w edytorze <span class="notranslate">object</span>, a następnie wybierając inną stronę <span class="notranslate">object</span> z przeglądarki <span class="notranslate">Asset</span> Browser
    który ma być &quot;rodzicem&quot; edytowanego pliku:</p>
  <p><img>Tak więc każda strona <span class="notranslate">object</span> w projekcie gry może mieć rodzica <span class="notranslate">object</span>, ale co to oznacza? Cóż, gdy <span class="notranslate">object</span> ma przypisanego rodzica, może
    współdzielić kod, akcje i zdarzenia z rodzicem. To współdzielenie jest nazywane &quot;dziedziczeniem&quot;, a <span class="notranslate">object</span>, który ma rodzica, jest nazywany &quot;dzieckiem&quot; <span class="notranslate">object</span>. Dziecko nie tylko może współdzielić kod ze swoim rodzicem, ale można też sprawdzać i uruchamiać kod
    na rodzica <span class="notranslate">objects</span> i automatycznie uwzględni on również dziecko <span class="notranslate">objects</span>, co pozwala zaoszczędzić wiele czasu i energii.</p>
  <p>Jeśli brzmi to skomplikowanie, to innym sposobem spojrzenia na stronę <span class="notranslate">object</span> jest sposób na &quot;zgrupowanie&quot; <span class="notranslate">objects</span> pod jednym parasolem i umożliwienie im dzielenia pewnych rzeczy bez utraty własnej, niepowtarzalnej tożsamości. Może to nadal nie
    nie wyjaśnia zbyt wiele, więc podajmy kilka przykładów...</p>
  <p>Załóżmy, że masz &quot;gracza&quot; <span class="notranslate">object</span> i czterech różnych &quot;wrogów&quot; <span class="notranslate">objects</span>. Teraz chcesz, aby gracz zginął, jeśli dotknie któregoś z tych czterech <span class="notranslate">objects</span>. W normalnych warunkach wymagałoby to czterech różnych zdarzeń kolizji z czterema różnymi zestawami
    działań lub kodu, po jednym dla każdego z wrogów <span class="notranslate">objects</span>. ALE jeśli dla wszystkich wrogów utworzymy nadrzędny <span class="notranslate">object</span>, możemy utworzyć jedno zdarzenie kolizji tylko z nadrzędnym <span class="notranslate">object</span> i będzie ono wywoływane niezależnie od tego, które z czterech &quot;dzieci&quot; wroga
    <span class="notranslate">objects</span> dotknie gracza. Przydatna rzecz! W rzeczywistym programie <span data-keyref="GameMaker Name">GameMaker</span> <span class="notranslate">object</span> zobaczyłbyś coś takiego:</p>
  <p><img>Po lewej stronie mamy cztery osobne zdarzenia kolizji, a po prawej jedno zdarzenie kolizji, ponieważ utworzyliśmy
    &quot;rodzica&quot; <span class="notranslate">object</span> i przypisaliśmy do niego wszystkie wrogie <span class="notranslate">objects</span>. Zauważ, że strona nadrzędna <span class="notranslate">object</span> nie musi mieć żadnych zdarzeń ani kodu...</p>
  <p>Innym przykładem parentingu może być gra, w której chcesz stworzyć 10 różnie wyglądających stron <span class="notranslate">objects</span> i sprawić, by wszystkie zachowywały się w ten sam sposób. W tym celu należałoby utworzyć jedną stronę nadrzędną <span class="notranslate">object</span> i w niej umieścić wszystkie akcje związane z zachowaniem lub kod
    w wymaganych zdarzeniach, a następnie utworzysz dziesięć <span class="notranslate">objects</span> bez żadnych akcji ani kodu, ale z różnymi <span class="notranslate">sprites</span>, i przypiszesz im swojego rodzica <span class="notranslate">object</span>. Teraz, gdy umieścisz te instancje w witrynie <span class="notranslate">room</span>, wszystkie będą zachowywać się tak samo, ale będą wyglądać inaczej,
    ponieważ &quot;odziedziczą&quot; zdarzenia po rodzicu.</p>
  <p>Wreszcie, można używać funkcji rodzicielskich do &quot;mieszania i dopasowywania&quot; zdarzeń i zachowań. Zilustrujemy to na ostatnim przykładzie... Powiedzmy, że chcemy mieć dwa potwory: jeden porusza się w górę i w dół, a drugi w lewo i w prawo.
    aby oba potwory miały takie samo zdrowie, strzelały do gracza i zadawały mu obrażenia, jeśli się z nimi zderzy. W tym przypadku widać, że prawie wszystkie zdarzenia powinny mieć takie same akcje, z wyjątkiem jednego lub dwóch, które regulują ruch. Ponownie możemy więc sprawić, że
    jeden <span class="notranslate">object</span> rodzicem drugiego, ale w tym przypadku definiujemy także pewne zdarzenia dla dziecka <span class="notranslate">object</span>. Te zdarzenia &quot;nadpisują&quot; zdarzenia rodzica, co oznacza, że gdy zdarzenie dla dziecka <span class="notranslate">object</span> zawiera akcje, są one wykonywane
    zamiast akcji zawartych w zdarzeniu rodzica. Jeśli chcesz także wykonać zdarzenie rodzica, możesz wywołać tak zwane zdarzenie &quot;dziedziczone&quot;, używając funkcji <a href="../../GameMaker_Language/GML_Reference/Asset_Management/Objects/Object_Events/event_inherited.htm"><span class="inline">event_inherited()</span></a>,
    lub akcji wizualnej <span class="notranslate">GML</span> Visual <a href="../../Drag_And_Drop/Drag_And_Drop_Reference/Instance/Call_Parent_Event.htm">Call Parent Event</a>.</p>
  <p><img>Po lewej stronie znajduje się strona nadrzędna <span class="notranslate">object</span> z 5 zdarzeniami, a po prawej stronie - &quot;dziecko&quot; <span class="notranslate">object</span>. Obiekt dziecka
    również ma 5 zdarzeń, ale dwa z nich zastępują zdarzenia odziedziczone po rodzicu (zdarzenia <strong>Krok </strong>i <strong>Rysuj </strong>), a pozostałe trzy są wyszarzone, ponieważ są to zdarzenia odziedziczone po rodzicu. Zdarzenia dziedziczone
    będą miały również ikonę &quot;nadpisania przez rodzica&quot; w edytorze zdarzeń:</p>
  <p><img>Po kliknięciu na stronie <img> zdarzenia, które zostało odziedziczone,
    otworzy się edytor kodu, aby wyświetlić odziedziczony kod rodzica, ale nie będzie można edytować tego kodu, ponieważ można go edytować tylko w samym rodzicu <span class="notranslate">object</span>. Kliknięcie prawym przyciskiem myszy <img> na dowolnym zdarzeniu nadrzędnym spowoduje otwarcie następującego menu opcji:</p>
  <p><img>W tym miejscu można wybrać dwie opcje <strong>Otwórz </strong>zdarzenie nadrzędne, aby sprawdzić kod, lub można wybrać opcję <strong>Dziedziczenie </strong>zdarzenia
    lub <strong>Zastąpić </strong>zdarzenie. Jeśli wybierzesz opcję <strong>Dziedziczenie </strong>, edytor kodu zostanie otwarty z funkcją <a href="../../GameMaker_Language/GML_Reference/Asset_Management/Objects/Object_Events/event_inherited.htm"><span class="inline">event_inherited()</span></a> już
    (lub akcją <a href="../../Drag_And_Drop/Drag_And_Drop_Reference/Instance/Call_Parent_Event.htm">Call Parent Event</a>, jeśli używasz <span class="notranslate">GML</span> Visual). Każdy kolejny kod umieszczony w tym zdarzeniu zostanie uruchomiony tak samo, jak kod obiektu nadrzędnego
    ma. Jeśli wybierzesz opcję <strong>Zastąp </strong>zdarzenie, okno z kodem również zostanie otwarte, ale teraz funkcja <span class="inline">event_inherited()</span> nie zostanie wywołana, więc wszystko, co dodasz w tym miejscu, zostanie uruchomione <em>zamiast </em>kodu
    w obiekcie nadrzędnym <span class="notranslate">object</span>.</p>
  <p class="note"><strong>UWAGA</strong>: W edytorze kodu można szybko przejść do strony nadrzędnej <span class="notranslate">object</span>, klikając prawym przyciskiem myszy <img> i wybierając z menu podręcznego polecenie <strong>Przejdź do obiektu</strong>, lub (jeśli zdarzenie zostało nadpisane) można wybrać polecenie <strong>Otwórz</strong> zdarzenie <strong>dziedziczone</strong>, aby przejść bezpośrednio do edytora kodu z kodem zdarzenia nadrzędnego.</p>
  <p>Zawsze, gdy w kodzie jest mowa o instancjach rodzica <span class="notranslate">object</span>, kod ten zostanie zastosowany także do &quot;dzieci&quot; rodzica <span class="notranslate">object</span>. Dzieje się tak, gdy w akcji wskażesz, że akcja musi być zastosowana do instancji określonego obiektu <span class="notranslate">object</span>, a w kodzie
    dzieje się to, gdy używasz <a href="../../GameMaker_Language/GML_Overview/Language_Features/with.htm"><span class="inline">with()</span></a> oświadczenia. Tak samo będzie to działać, gdy wywołasz w kodzie funkcje, takie jak <a href="../../GameMaker_Language/GML_Reference/Asset_Management/Instances/instance_position.htm"><span class="inline">instance_position()</span></a>,
    <a href="../../GameMaker_Language/GML_Reference/Asset_Management/Instances/instance_number.htm"><span class="inline">instance_number()</span></a>, itp... gdzie - jeśli podasz adres nadrzędny <span class="notranslate">object</span> - wszystkie instancje rodzica <em>i </em>dziecka
    zostaną uwzględnione w sprawdzeniach. Wreszcie, parenting działa także w przypadku odwoływania się do zmiennych w innych witrynach <span class="notranslate">objects</span>, np. w powyższym przykładzie potwora, jeśli ustawię prędkość wroga 1 na 10, to prędkość wroga 2 również wyniesie 10, ponieważ jest on dzieckiem <span class="notranslate">object</span> wroga
    1.</p>
  <p> <span class="notranslate">object</span> W większości przypadków za dobrą praktykę uważa się tworzenie jednego rodzica <span class="notranslate">object</span> i umieszczanie w nim wszystkich domyślnych zachowań, ale nigdy nieużywanie jego instancji w grze. Należy raczej używać wszystkich dzieci <span class="notranslate">objects</span> i korzystać z rodzica tylko w
    w sytuacjach takich jak te, które opisałem powyżej, w przypadku kolizji, odwołań do zmiennych itp. Powinieneś także zdawać sobie sprawę, że rodzice mogą mieć rodziców! Oczywiście nie można utworzyć cyklu &quot;rodzic 1 jest dzieckiem rodzica 2 jest dzieckiem rodzica
    1&quot;, ale możesz stworzyć tak zwaną &quot;hierarchię obiektów&quot;, gdzie &quot;<em>rodzic3 </em>jest dzieckiem <em>rodzica2 </em>jest dzieckiem <em>rodzica1</em>&quot;. Jest to niezwykle użyteczne, aby zachować strukturę gry i zdecydowanie zaleca się
    nauczenie się korzystania z tego mechanizmu.</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Powrót: <a href="../Objects.htm">Redaktor <span class="notranslate">Object</span> </a></div>
        <div style="float:right">Następny: <a href="Physics_Objects.htm">Obiekty fizyki</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Wszystkie prawa zastrzeżone.</span></h5>
  </div>
  <!-- KEYWORDS
Parent Objects
Child Objects
parent
child
inheritance
-->
  <!-- TAGS
parent_objects
-->
</body>
</html>