<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Rysowanie wydarzeń</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page detailing the draw event." />
  <meta name="rh-index-keywords" content="Objects - Draw Events" />
  <meta name="search-keywords" content="draw event,draw begin,draw end,pre-draw,post draw,draw GUI,draw order" />
  <link rel="stylesheet" type="text/css" href="../../assets/css/default.css" />
  <script src="../../assets/scripts/main_script.js"></script>
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Wydarzenia związane z losowaniem</h1>
  <p><img>Kategoria Rysuj zdarzenia zawiera wszystkie zdarzenia, które wpływają na to, co widać na ekranie po uruchomieniu gry. Jest ona podzielona na różne
    aby lepiej radzić sobie z różnymi wymaganiami dotyczącymi rysowania w grze. Poniższa ilustracja przedstawia kolejność wykonywania poszczególnych zdarzeń:</p>
  <p><img>Zwykłe zdarzenie Draw dzieli się na trzy podtypy: <strong>Początek</strong> rysunku, Standardowy rysunek i Koniec <strong>rysunku</strong>.
    Draw <strong>End</strong>. Ogólnie rzecz biorąc, będziesz musiał używać tylko standardowego zdarzenia Draw i powinieneś wiedzieć, że wszystkie instancje w <span class="notranslate">room</span> będą miały wywoływane to zdarzenie w każdym kroku gry, więc zdarzenie to będzie zawsze wywoływane, dopóki
    jeśli instancja ma ustawioną flagę <strong>visible </strong>na true. Ważne jest, by zrozumieć, że nawet jeśli nie zdefiniowałeś nic dla tego podzdarzenia we właściwościach <span class="notranslate">object</span> (tzn. żadnego kodu ani akcji), to <em>jeśli <span class="notranslate">object</span> ma przypisaną stronę <span class="notranslate">sprite</span>, to i tak zdarzenie draw</em> zostanie wywołane.
    Dzieje się tak dlatego, że <span data-keyref="GameMaker Name">GameMaker</span> ma dwa sposoby rysowania rzeczy w zdarzeniu Draw:</p>
  <ul class="colour">
    <li>rysowanie <strong>domyślne</strong>, czyli takie, w którym definiujesz stronę <span class="notranslate">sprite</span> we właściwościach <span class="notranslate">object</span> i nie umieszczasz żadnych akcji ani kodu w normalnym zdarzeniu Draw, a w tym przypadku <span data-keyref="GameMaker Name">GameMaker</span> automatycznie narysuje przypisaną stronę <span class="notranslate">sprite</span>. Należy pamiętać, że wszelkie transformacje
      które wykonasz w innych zdarzeniach, aby zmienić skalę obrazu, indeks, mieszanie itp. zostaną również uwzględnione, o ile zdarzenie Draw jest puste.</li>
    <li> <strong>niestandardowe</strong> rysowanie, które polega na umieszczeniu kodu lub akcji w zdarzeniu rysowania. W ten sposób mówisz <span data-keyref="GameMaker Name">GameMakerowi</span>: &quot; <em>Chcę kontrolować, co rysujesz dla instancji tego obiektu</em>&quot; i całkowicie zastępujesz domyślne
      rysowanie. Oznacza to, że na przykład możesz mieć <span class="notranslate">object</span> z przypisanym <span class="notranslate">sprite</span>, następnie ustawić zdarzenie draw na draw text i tekst zostanie narysowany na ekranie, ale <span class="notranslate">sprite</span> <em>nie </em>zostanie narysowany, ponieważ nie kazałeś <span data-keyref="GameMaker Name">GameMakerowi</span> 
      narysować go razem z tekstem.</li>
  </ul>
  <p>Pozostałe zdarzenia losowania są opisane w poniższych sekcjach:</p>
  <p> </p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#">Rysuj początek i rysuj koniec</a></p>
  <div class="droptext" data-targetname="drop-down">
    <p class="dropspot">Oprócz głównego zdarzenia Draw, masz także zdarzenia Draw <strong> Begin</strong> i <strong>Draw End</strong>. Zachowują się one dokładnie tak samo jak standardowe zdarzenia Draw (tzn. będą rysować wszystko, co w nich umieścisz, na każdym etapie gry i we wszystkich rzutniach).
      ), ale nie będą one &quot;domyślnie rysować&quot; niczego, jeśli nie zostały jawnie dodane do strony <span class="notranslate">object</span> i zawsze będą działać przed/po standardowym zdarzeniu Draw. Tak więc podczas gry <em>zawsze</em> będzie występować zdarzenie
      Draw Begin dla wszystkich instancji, następnie Draw dla wszystkich instancji, a na końcu Draw End dla wszystkich instancji.</p>
    <p class="dropspot">W ten sposób można rysować rzeczy lub ustawiać właściwości rysowania w kroku Rozpocznij rysowanie w jednej instancji i mieć pewność, że wszystkie instancje ze standardowym zdarzeniem Rysuj lub Zakończ rysowanie wykorzystają te właściwości lub narysują to, co narysowała pierwsza instancja. Zasadniczo
      jest to pewny sposób na zagwarantowanie, że pewne rzeczy zostaną narysowane w określonym czasie, podobnie jak robią to zdarzenia <strong>Begin Step</strong> i <strong>End Step </strong>.</p>
    <p class="dropspot">Podczas rysowania elementów w programie <span data-keyref="GameMaker Name">GameMaker</span> należy pamiętać o kilku rzeczach, niezależnie od tego, czy jest to rysunek <span class="notranslate">sprite</span>, <span class="notranslate">shader</span> czy bufor 3D:</p>
    <ul class="colour">
      <li class="dropspot">Zdarzenie draw jest bardzo intensywne, ponieważ jest to jedno ze zdarzeń, które pochłania najwięcej czasu i zasobów... z tego powodu nie jest dobrym pomysłem robienie w zdarzeniu draw czegokolwiek innego niż rysowanie. Zachowaj więc swój duży kod lub złożone działania
        dla zdarzenia Step lub Alarms, lub jakiegokolwiek innego zdarzenia, ale pozostaw zdarzenie draw dla rysowania, ponieważ to jest to, co robi najlepiej.</li>
      <li class="dropspot">Jeśli dla strony <span class="notranslate">object</span> parametr visible ustawiono na <em>off </em>(czyli instancje strony <span class="notranslate">object</span> nie są <strong>rysowane </strong>), to <strong>wszystkie zdarzenia rysowania są pomijane </strong>(z wyjątkiem zdarzenia <strong>Resize </strong>). Oznacza to, że uczynienie instancji
        niewidzialną spowoduje, że cały kod umieszczony w którymkolwiek z tych zdarzeń przestanie działać, więc nie umieszczaj istotnego kodu w zdarzeniach rysowania, jeśli nie mają być one widoczne.</li>
      <li class="dropspot">To, co narysujesz, nie ma nic wspólnego z wybranym silnikiem kolizyjnym (tradycyjnym lub fizycznym), ponieważ jest on definiowany przez właściwości <span class="notranslate">object</span> i adres <span class="notranslate">sprite</span> (lub maskę), który został nadany stronie <span class="notranslate">object</span>.</li>
    </ul>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">Rysuj GUI</a></p>
  <div class="droptext" data-targetname="drop-down1">
    <p class="dropspot">Typ zdarzenia Rysuj GUI należy do kategorii Zdarzenie rysunku i jest przeznaczony specjalnie do rysowania elementów <a class="glossterm" data-glossterm="GUI" href="#">GUI</a>, na które nie ma wpływu skala ani obrót kamery widoku. Oznacza to, że
      że instancja może rysować wszystkie elementy <a class="glossterm" data-glossterm="HUD" href="#">HUD</a> lub interfejsu użytkownika bez konieczności opierania pozycjonowania elementów na pozycji instancji w <span class="notranslate">room</span> lub pozycji
      bieżącego widoku z kamery.</p>
    <p class="dropspot">Podczas rysowania w tym przypadku należy pamiętać, że współrzędne rysowania nie zmieniają się nawet wtedy, gdy aktywne są widoki z kamery, a (0,0) jest <em>zawsze </em>lewym górnym rogiem powierzchni aplikacji lub wyświetlacza (zob.
      w dolnej części tej sekcji), a domyślna szerokość i wysokość są ustawione w stosunku 1:1 z powierzchnią aplikacji. Porządek głębokości jest nadal zachowywany między instancjami na różnych warstwach (instancja na wyższej warstwie będzie rysowana pod instancją na niższej warstwie), a także
      na niższej warstwie), a także w samych zdarzeniach, ponieważ zdarzenie <strong>Draw GUI Begin</strong> narysuje najpierw wszystkie instancje, następnie standardowe <strong>Draw GUI</strong> narysuje wszystkie instancje powyżej, a na końcu zostanie wywołane zdarzenie Draw <strong>Gui End </strong>
      jest wywoływane.</p>
    <p class="dropspot">W ten sposób można rysować rzeczy lub ustawiać właściwości rysowania w zdarzeniu Draw GUI Begin w jednej instancji i mieć pewność, że wszystkie instancje ze standardowym zdarzeniem Draw GUI lub Draw GUI End będą używać tych właściwości lub rysować ponad to, co narysowała pierwsza instancja. Zasadniczo
      jest to pewny sposób na zagwarantowanie, że pewne rzeczy zostaną narysowane w określonym czasie, podobnie jak robią to zdarzenia <strong>Begin Step</strong> i <strong>End Step</strong>.</p>
    <p class="dropspot">Zdarzenia te mogą być także używane w połączeniu z normalnymi zdarzeniami Draw (na które będą miały wpływ pozycja, skala i obrót widoku kamery). Jeśli nie masz zdarzenia Draw Event, ale masz Draw GUI Event, to <span data-keyref="GameMaker Name">GameMaker</span> nadal będzie
      domyślnie narysuje stronę <span class="notranslate">sprite</span> dla danej instancji (jeśli ją posiada) w normalny sposób.</p>
    <p class="dropspot">W odniesieniu do innych zdarzeń rysowania, zdarzenia Draw GUI zawsze będą rysować nad wszystkim, co zostało narysowane w normalnych zdarzeniach rysowania. Tak więc, jeśli masz instancję na niższej warstwie ze zdarzeniem Draw GUI, będzie ona rysowana nad instancją, która znajduje się na wyższej warstwie
      z normalnym zdarzeniem rysowania. Jeśli obie instancje mają zdarzenie Draw GUI, to kolejność warstw zostanie zachowana.</p>
    <p class="note"><strong>UWAGA</strong>: To zdarzenie domyślnie będzie rysować 1:1 z rozmiarem powierzchni aplikacji, który zwykle jest rozmiarem <span class="notranslate">room</span> lub portu widoku. Oznacza to, że jeśli w opcjach gry włączona jest <strong>korekcja współczynnika proporcji (Aspect Ratio Correction</strong> )
      GUI nie będzie rysowany nad czarnymi pasami, które &quot;literują&quot; grę. To zachowanie można wyłączyć za pomocą <a href="../../GameMaker_Language/GML_Reference/Cameras_And_Display/display_set_gui_maximise.htm"><span style="font-size:14px;"> <span class="inline" style="font-size: 14px">display_set_gui_maximise()</span></span></a> funkcji,
      Można również zablokować zdarzenie GUI do określonego rozmiaru, który będzie automatycznie skalowany w celu dopasowania do wymiarów wyświetlacza lub powierzchni aplikacji za pomocą funkcji <a href="../../GameMaker_Language/GML_Reference/Cameras_And_Display/display_set_gui_size.htm"><span class="inline" style="font-size: 14px">display_set_gui_size()</span></a>.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#">Przed i po losowaniu</a></p>
  <div class="droptext" data-targetname="drop-down2">
    <p class="dropspot">Zdarzenia Pre Draw i Post Draw należą do kategorii zdarzeń Draw. Jednak w odróżnieniu od innych zdarzeń Draw, te rysują <em>bezpośrednio </em>do <a class="glossterm" data-glossterm="bufor wyświetlacza" href="#">bufora wyświetlacza</a>, który będzie miał rozmiar
      łącznego obszaru ekranu dla wszystkich aktualnie widocznych rzutni <em>lub </em>rozmiaru okna, jeśli używana jest tylko jedna rzutnia lub żadna. Ilustruje to poniższy rysunek:</p>
    <p class="dropspot"><img>Jeśli więc używasz zdarzeń Pre lub Post draw, rysujesz do pełnoekranowego obiektu docelowego renderowania (display <span class="notranslate">buffer</span>), który będzie miał
      taki sam rozmiar jak okno, do którego dopasowywane są wszystkie rzutnie. Jeśli nie ma aktywnych rzutni, rozmiar ten jest ustawiany na wielkość samego okna.</p>
    <p class="dropspot">Zdarzenie Pre Draw jest wywoływane przed każdym innym zdarzeniem rysowania i można w nim ustawiać wartości, właściwości rysowania, a nawet rysować rzeczy, nie przejmując się rzutniami ani rozmiarem warstwy GUI (rozmiar warstwy GUI może być taki sam jak ekranu
     <span class="notranslate">buffer</span> ale może też nie być, ponieważ rozdzielczość GUI można ustawić w kodzie).</p>
    <p class="dropspot">Warto zauważyć, że to zdarzenie ma miejsce, <em>zanim </em>ekran <span class="notranslate">buffer</span> zostanie wyczyszczony do normalnego rysowania, co oznacza, że jeśli nie <span class="notranslate">switch</span> wyłączysz wyczyszczenia widoku w edytorze <span class="notranslate">room</span>, nic, co zostanie narysowane w zdarzeniu Pre Draw, nie będzie widoczne, ponieważ
      ponieważ pierwsze rysowanie rzutni spowoduje jej wyczyszczenie. Jeśli chcesz widzieć przez same rzutnie lub w ogóle nie używasz rzutni, powinieneś ustawić kolor tła na alfa równy 0 w polu <strong><a href="../Rooms.htm">Edytor pokoju</a></strong>.</p>
    <p class="note"><strong>UWAGA</strong>: Jeśli <span class="notranslate">switch</span> wyłączysz te opcje, możesz zauważyć niepożądane artefakty rysowane na ekranie podczas testowania gry (np. &quot;smugi&quot; po instancjach). Dzieje się tak dlatego, że rysujesz bezpośrednio nad poprzednią klatką
      wyświetlacza <span class="notranslate">buffer</span> bez jej wyczyszczenia. Możesz jednak użyć <span class="inline" style="font-size: 14px"><a href="../../GameMaker_Language/GML_Reference/Drawing/Colour_And_Alpha/draw_clear_alpha.htm">draw_clear_alpha()</a> </span>aby to zrobić
      samodzielnie.</p>
    <p class="dropspot">Zdarzenie Post Draw jest wywoływane <em>po </em>wszystkich standardowych zdarzeniach rysowania, ale <em>przed </em>zdarzeniami Draw GUI. Podobnie jak zdarzenie Pre Draw, jest ono oparte na rozmiarze ekranu <span class="notranslate">buffer</span> i jest umieszczane przed zdarzeniami Draw GUI, aby umożliwić
      wykonywanie efektów post-processingu i innych czynności na pełnym ekranie w prosty i łatwy sposób, bez zakłócania działania elementów <a class="glossterm" data-glossterm="HUD" href="#">HUD/</a> <a class="glossterm" data-glossterm="GUI" href="#">GUI</a> 
      które mogą występować w grze.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down3" href="#">Zmiana rozmiaru okna</a></p>
  <div class="droptext" data-targetname="drop-down3">
    <p class="dropspot">Ten typ zdarzenia należy do kategorii zdarzeń rysowania i choć w rzeczywistości niczego nie rysuje, to reaguje na zmiany w wyświetlanym obrazie <span class="notranslate">buffer</span> - w szczególności jest przeznaczony do reagowania na zmianę rozmiaru ekranu <span class="notranslate">buffer</span> UWP, gdy okno gry jest "przyciągane".
      gdy okno gry jest &quot;przyciągane&quot;.</p>
    <p class="dropspot">Na platformie docelowej UWP ważne jest, aby wychwycić każdą zmianę rozmiaru wyświetlacza <span class="notranslate">buffer</span> spowodowaną &quot;przytrzaśnięciem&quot; okna gry (na przykład gdy użytkownik przeciągnie okno na bok wyświetlacza). To zdarzenie właśnie to robi i
      jest wywoływane za każdym razem, gdy okno jest zmieniane, co pozwala na dodanie własnego kodu, który będzie zmieniał rozmiar widoku lub położenie elementów <a class="glossterm" data-glossterm="HUD" href="#">HUD</a>. Funkcja ta została udostępniona jako wygodny
      wygodny sposób na uniknięcie konieczności ciągłego sprawdzania kodu zdarzeń, który sprawdza te rzeczy.</p>
    <p class="note"><strong>UWAGA</strong>: Nie można rysować w tym zdarzeniu! Jest ono wywoływane przez zmianę rozmiaru okna i służy tylko do wychwycenia tej zmiany... wszelkie rysowanie, które powinno być wykonane, musi być wykonane w jednym z innych zdarzeń draw.</p>
    <p class="dropspot"> </p>
  </div>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Powrót: <a href="Object_Events.htm">Zdarzenia dotyczące obiektów</a></div>
        <div style="float:right">Następny: <a href="Async_Events.htm">Zdarzenia asynchroniczne</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Wszystkie prawa zastrzeżone.</span></h5>
  </div>
  <!-- KEYWORDS
Draw Events
Pre Draw Event
Post Draw Event
Draw Begin Event
Draw End Events
Draw GUI Events
Draw GUI Begin Event
Draw GUI End Event
Pre Draw Event
Post Draw Event
Window Resize Event
-->
  <!-- TAGS
draw_events
-->

</body></html>