<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Wydarzenia dotyczące obiektów</title>
    <meta name="generator" content="Adobe RoboHelp 2020" />
    <meta name="rh-authors" content="Mark Alexander" />
    <meta name="topic-comment" content="Page detailing the events system and the different events in an object" />
    <meta name="rh-index-keywords" content="Objects - Events" />
    <meta name="search-keywords" content="events,object events,events list" />
    <link rel="stylesheet" type="text/css" href="../../assets/css/default.css" />
    <script src="../../assets/scripts/main_script.js"></script>
  </head>
  <body><!--<div class="body-scroll" style="top: 150px;">-->
    <h1>Wydarzenia dotyczące obiektów</h1>
    <p>Czym więc są <strong>wydarzenia</strong> <span class="notranslate">object</span>? Zasadniczo są to dyskretne momenty w grze <span class="notranslate">loop</span>, w których rzeczy dzieją się zgodnie z tym, co dla nich zaprogramowałeś. <span data-keyref="GameMaker Name">GameMaker</span> pracuje z cyklami takich zdarzeń - od momentu uruchomienia <span class="notranslate">room</span> do jego zakończenia toczy się gra <span class="notranslate">loop</span>, w której co <strong>krok </strong>uruchamiana lub sprawdzana jest seria zdarzeń, a Ty możesz umieścić w swojej <span class="notranslate">GML</span> kod lub <span class="notranslate">objects</span> wizualne akcje, które reagują na te zdarzenia (krok to moment w czasie gry, regulowany przez ustawienia <span class="notranslate">room</span> speed, może być też nazywany <strong>klatką</strong>).</p>
    <p>Przyjrzyjmy się typowej konfiguracji strony <span class="notranslate">object</span> z uwzględnieniem zdarzeń i kodu:</p>
    <p><img>Jak widać na naszym przykładzie <span class="notranslate">object</span>, na liście znajduje się wiele zdarzeń, na które powinna ona reagować, ale początkowo, gdy tworzysz stronę <span class="notranslate">object</span>, lista ta jest pusta i musisz zdecydować, które zdarzenia są potrzebne i co instancje tej strony <span class="notranslate">object</span> powinny zrobić, gdy te zdarzenia zostaną wywołane. Aby dodać zdarzenia do <span class="notranslate">object</span>, należy nacisnąć przycisk <em>Dodaj</em> zdarzenie znajdujący się na dole listy zdarzeń, co spowoduje wyświetlenie następującego okna:</p>
    <p><img>Jest to lista wszystkich podstawowych zdarzeń i kategorii zdarzeń, na które może reagować <span class="notranslate">object</span>, a w ramach każdej kategorii znajdują się zdarzenia podrzędne, które umożliwiają dalsze doprecyzowanie zachowań. Na przykład, jeśli klikniesz kategorię zdarzeń<strong>Naciśnięcie</strong> <strong>klawisza</strong> <img>, pojawi się kolejne okno ze zdarzeniami, które pozwalają wybrać, na <em>który </em>klawisz ma reagować <span class="notranslate">object</span>.</p>
    <p>Po wybraniu zdarzenia zostanie do niego dołączone okno edytora zdarzeń, które zostanie otwarte po prawej stronie.</p>
    <div data-conref="../../assets/snippets/Visual_Code_Choice.hts"> </div>
    <p>Teraz można edytować kod (lub bloki) <span class="notranslate">GML</span>, aby nadać witrynie <span class="notranslate">object</span> określone zachowanie lub reakcję na dane zdarzenie.</p>
    <p>Można kliknąć prawym przyciskiem myszy <img> na dowolnym zdarzeniu, które zostało dodane do strony <span class="notranslate">object</span>, aby uzyskać następujące opcje menu:</p>
    <p><img>Są to następujące opcje:</p>
    <ul class="colour">
      <li><strong>Dodaj</strong> wydarzenie - dodawanie nowego wydarzenia z listy wydarzeń.</li>
      <li>Wytnij<strong>/ </strong> <strong>Kopiuj / </strong> <strong>Wklej</strong> zdarzenia - Wytnij, skopiuj lub wklej wybrane zdarzenie. Można też użyć standardowych skrótów klawiaturowych: <img> / <img> + <span class="inline">X</span>, <img> / <img> + <span class="inline">C</span>, oraz <img> / <img> + <span class="inline">V</span>.</li>
      <li><strong>Duplikuj</strong> zdarzenie - powiela wybrane zdarzenie. Spowoduje to pobranie zawartości wybranego zdarzenia i powielenie jej w innym, określonym przez użytkownika zdarzeniu.</li>
      <li><strong>Zmień</strong> wydarzenie - zmiana wydarzenia. Zostanie wyświetlony monit o wybranie innej kategorii wydarzenia, a po jej wybraniu zawartość bieżącego wydarzenia zostanie zmieniona na nowe wydarzenie (usuwając przy okazji oryginalne wydarzenie).</li>
      <li><strong>Convert To <span class="notranslate">GML</span> Visual / Code</strong> - zdarzenia <span class="notranslate">Object</span> zostaną utworzone przy użyciu metody wybranej podczas tworzenia projektu, albo przy użyciu kodu, albo przy użyciu akcji <span class="notranslate">GML</span> Visual. Dzięki tej opcji można konwertować z jednej na drugą, niezależnie od typu projektu.</li>
      <li><strong>Usuń</strong> zdarzenie - usuwa zdarzenie (lub zdarzenia).</li>
    </ul>
    <p>Podczas usuwania zdarzeń można użyć <img> + <img>, aby zaznaczyć wiele zdarzeń, a następnie usunąć je wszystkie razem. Każda utworzona strona <span class="notranslate">object</span> ma własną listę zdarzeń, które są do niej dodawane z <strong>Edytora obiektów</strong>. Zdarzenia te dzielą się na dwie kategorie:</p>
    <ul class="colour">
      <li>te, które uruchamiają każdy krok gry</li>
      <li>te, które są &quot;wyzwalane&quot; przez zdarzenie w grze, takie jak osiągnięcie przez instancję krawędzi <span class="notranslate">room</span> lub naciśnięcie klawiatury albo myszy.</li>
    </ul>
    <p>Pełna lista wydarzeń znajduje się poniżej:</p>
    <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down8" href="#">Utwórz stronę</a></p>
    <div class="droptext" data-targetname="drop-down8">
      <p class="dropspot">To zdarzenie ma miejsce, gdy po raz pierwszy tworzona jest instancja <span class="notranslate">object</span>, i jest pierwszą rzeczą, która dzieje się w instancji umieszczonej w <span class="notranslate">room</span> za pośrednictwem edytora <span class="notranslate">Room</span> po wejściu na stronę <span class="notranslate">room</span>. Oznacza to, że to zdarzenie jest idealnym miejscem do inicjalizacji <a class="glossterm" data-glossterm="zmienna" href="#">zmiennych</a>, uruchamiania <a href="../Timelines.htm">linii czasowych</a>, ustawiania <a href="../Paths.htm">ścieżek</a> itp. oraz wykonywania wszelkich innych czynności, które zazwyczaj muszą być wykonane tylko raz lub tylko podczas pierwszego tworzenia instancji w <span class="notranslate">room</span>. Jeśli na stronie <span class="notranslate">object</span> dodano zmienne <strong>obiektu</strong> lub <strong>zmienne</strong> instancji w Edytorze <span class="notranslate">Object</span> lub Edytorze <span class="notranslate">Room</span>, zmienne te zostaną najpierw zainicjowane, a następnie zostanie uruchomione zdarzenie <strong>Create Event</strong>.</p>
      <p class="dropspot">Pamiętaj, że wszystko, co zostało ustawione w zdarzeniu tworzenia, możesz modyfikować w <a href="../Room_Properties/Layer_Properties.htm">kodzie</a> tworzenia instancji w edytorze <span class="notranslate">Room</span>, ponieważ jest on uruchamiany bezpośrednio po zdarzeniu tworzenia instancji i może być użyty do tworzenia <strong>zmiennych</strong> instancji lub zastępowania zmiennych dodanych jako zmienne <span class="notranslate">Object</span> lub w samym zdarzeniu tworzenia.</p>
      <div data-conref="../../assets/snippets/Instance_creation_order_warning.hts"> </div>
      <p class="dropspot"> </p>
    </div>
    <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down9" href="#">Zniszcz</a></p>
    <div class="droptext" data-targetname="drop-down9">
      <p class="dropspot">To zdarzenie jest zdarzeniem, które zostanie wykonane, gdy instancja zostanie zniszczona. Często jest ono pomijane przy dodawaniu zachowań do <span class="notranslate">objects</span>, ale może być bardzo użyteczne, na przykład przy tworzeniu efektów eksplozji lub cząsteczek po zabiciu wroga, lub przy ponownym uruchomieniu nowej instancji <span class="notranslate">object</span> w innej części <span class="notranslate">room</span>, a nawet przy dodawaniu punktów do wyniku.</p>
      <p class="dropspot"> </p>
    </div>
    <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down10" href="#">Sprzątanie</a></p>
    <div class="droptext" data-targetname="drop-down10">
      <p class="dropspot"><span>To zdarzenie zostanie wywołane po każdym zdarzeniu, które spowoduje usunięcie instancji <span class="notranslate">object</span> z witryny <span class="notranslate">room</span>. Zostanie więc wywołane, jeśli:</span></p>
      <ul class="dropspotlist">
        <li class="dropspot"><span>instancja zostanie zniszczona</span></li>
        <li class="dropspot"><span> <span class="notranslate">room</span> kończy się</span></li>
        <li class="dropspot"><span>gra się kończy</span></li>
      </ul>
      <p class="dropspot"><span>Jest on przeznaczony do &quot;czyszczenia&quot; wszelkich zasobów dynamicznych, które możesz mieć w swojej grze (takich jak powierzchnie, struktury danych itp.), lub do wykonywania dowolnych zadań, które musisz wykonać <em>raz </em>, gdy instancja zostanie w jakikolwiek sposób usunięta z gry.</span></p>
      <p class="dropspot"><span>Zauważ, że to zdarzenie zostanie wywołane <em>natychmiast </em>po zdarzeniu, które je wywołało, ale instancja nie zostanie faktycznie usunięta z gry <strong>aż do zakończenia bieżącego</strong> zdarzenia. Na przykład, jeśli wywołasz <span class="inline">instance_destroy()</span> w zdarzeniu Step, zostanie wywołane zdarzenie Destroy, następnie zdarzenie Clean Up, a po nim <em>zakończy się reszta zdarzenia Step</em> Event. Oznacza to, że każdy kod, który zostanie wykonany po wywołaniu <span class="inline">instance_destroy()</span>, będzie nadal wykonywany i może być przyczyną błędów, jeśli wyczyszczono strukturę danych lub inny zasób wymagany przez ten kod, dlatego należy zachować ostrożność podczas korzystania z tego zdarzenia.</span> </p>
      <p> </p>
    </div>
    <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down11" href="#">Alarm</a></p>
    <div class="droptext" data-targetname="drop-down11">
      <p class="dropspot">Kategoria alarmów jest podzielona na 12 zdarzeń, po jednym dla każdego z możliwych alarmów, które można ustawić w danej instancji. Tak więc po kliknięciu kategorii <em>Dodaj </em>alarm pojawi się to okno:</p>
      <p class="dropspot"><img>W tym miejscu wybierasz alarm, który chcesz utworzyć, a po jego utworzeniu zobaczysz, że został on dodany do okna zdarzeń, dzięki czemu możesz normalnie dodawać do niego kod. Ale co to jest alarm? Jest to specjalne zdarzenie, które nic nie robi, chyba że alarm został wcześniej ustawiony, a następnie czeka, aż alarm odliczy do 0, zanim zostaną uruchomione działania lub kod, które zostały do niego dodane.</p>
      <p class="dropspot">Gdy alarm osiągnie wartość 0 i uruchomi kod, będzie odliczał do -1, gdzie pozostanie aż do ponownego ustawienia (co oznacza, że możesz sprawdzić, czy wartość alarmu jest większa niż -1, co powie Ci, czy jest on uruchomiony, czy nie). Tak więc, jeśli w zdarzeniu create <span class="notranslate">object</span> ustawisz wartość <span class="inline">alarm[0]</span> na 30, oznacza to, że <span data-keyref="GameMaker Name">GameMaker</span> będzie odliczał 30 kroków gry, zanim wykona akcje lub kod umieszczony w zdarzeniu <span class="inline">alarm[0]</span>. Zauważ, że ustawienie alarmu na 0 <em>nie </em>spowoduje uruchomienia kodu alarmu, ponieważ zdarzenie zostanie wywołane, ale alarm zostanie natychmiast ustawiony na -1, więc kod zostanie pominięty. Jeśli alarm ma być uruchamiany w następnym kroku, należy ustawić go na 1.</p>
      <p class="dropspot">Może to być bardzo użyteczne, ponieważ umożliwia wprawianie przedmiotów w ruch w ściśle określonych momentach, a nawet ich powtarzanie, ponieważ nic nie stoi na przeszkodzie, aby ustawić alarm w jego własnym zdarzeniu. Wyobraź sobie, że masz potwora i chcesz, aby skręcał w prawo co trzy sekundy... W zdarzeniu tworzenia ustawiasz alarm na prędkość <span class="notranslate">room</span> * 3 (jeśli prędkość <span class="notranslate">room</span> wynosi 30, to jest to 30 kroków na sekundę, więc pomnóż to przez 3 i otrzymasz 3 sekundy!), a następnie w zdarzeniu alarmu masz kod lub akcję, aby ustawić jego kierunek, a także akcję (lub kod), aby ustawić alarm na prędkość <span class="notranslate">room</span> * 3 ponownie. W ten sposób można skonfigurować prostą grę <span class="notranslate">loops</span>, w której pewne rzeczy dzieją się tylko w określonych odstępach czasu.</p>
      <p class="dropspot">Warto zauważyć, że alarm, w którym nie ma żadnych akcji ani kodu, <em>nie </em>będzie odliczał czasu. Jednak nawet w przypadku samego komentarza, bez kodu lub akcji, alarm będzie nadal odliczał czas i będzie można go ustawiać i sprawdzać w normalny sposób.</p>
      <p class="dropspot"> </p>
    </div>
    <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down12" href="#">Krok</a></p>
    <div class="droptext" data-targetname="drop-down12">
      <p class="dropspot"><span data-keyref="GameMaker Name">GameMaker</span> dzieli czas na <strong>kroki </strong>, a prędkość <span class="notranslate">room</span> określa, ile tych <strong>kroków </strong>powinno być na sekundę (krok można też nazwać <strong>klatką</strong>). Pojedynczy krok to w zasadzie strona <span class="notranslate">loop</span>, która działa bez przerwy, a wszystkie zdarzenia są sprawdzane i wywoływane w razie potrzeby, gdy gra działa, więc jak możesz sobie wyobrazić, zdarzenie <strong>Step </strong>jest zdarzeniem, które jest sprawdzane w każdym kroku gry, gdy instancja istnieje.</p>
      <p class="dropspot">Etap ten składa się z trzech etapów, które opisano poniżej:</p>
      <p class="dropspot"><img>Do większości rzeczy wystarczy standardowe zdarzenie kroku, ale czasami chcesz mieć większą kontrolę nad tym, jaki kod jest uruchamiany i w jakim czasie, więc w tym celu masz do dyspozycji zdarzenia kroku <strong>Begin </strong>i <strong>End </strong>. Wszystkie trzy są sprawdzane co krok, ale ich kolejność nigdy się nie zmieni, nawet jeśli przyszłe aktualizacje silnika <span data-keyref="GameMaker Name">GameMakera</span> zmienią inne zdarzenia, co oznacza, że jest to jedyna niezawodna metoda upewnienia się, że coś zawsze dzieje się przed czymś innym.</p>
      <p class="dropspot">Do czego można wykorzystać zdarzenie step? Cóż, można je wykorzystać do działań lub kodu, który musi być wykonywany w sposób ciągły. Na przykład, jeśli jedna strona <span class="notranslate">object</span> ma podążać za drugą, można tu dostosować kierunek ruchu w stronę strony <span class="notranslate">object</span>, za którą podążamy, aby ta poruszała się płynnie za nami. Należy jednak uważać z tym zdarzeniem i nie umieszczać wielu skomplikowanych akcji w zdarzeniu step w <span class="notranslate">objects</span>, zwłaszcza jeśli planujesz mieć wiele instancji <span class="notranslate">object</span> w swojej grze <span class="notranslate">room</span>, ponieważ może to spowolnić grę. Wiele rzeczy można umieszczać w alarmach lub ustawiać ich wyzwalanie za pomocą <strong>innych </strong>zdarzeń, zamiast wykonywać je przez cały czas.</p>
      <p class="dropspot"> </p>
      <p class="dropspot"> </p>
    </div>
    <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down13" href="#">Kolizja</a></p>
    <div class="droptext" data-targetname="drop-down13">
      <p class="dropspot">Oczywiście podczas tworzenia gry bardzo ważne jest, aby wiedzieć, kiedy dwie (lub więcej) instancje <span class="notranslate">object</span> zderzą się ze sobą, a do tego celu służy <strong>zdarzenie</strong> kolizji. Jest to zdarzenie, które umieszcza się w witrynie <span class="notranslate">object</span>, a następnie określa, w stosunku do których innych witryn <span class="notranslate">object</span> należy sprawdzać kolizje.</p>
      <p class="dropspot">Jeśli nie masz włączonej fizyki, kolizje te będą obliczane na podstawie maski obu <span class="notranslate">objects</span> (maska jest zdefiniowana we właściwościach <span class="notranslate">sprite</span> lub może być przypisana niezależnie we właściwościach <span class="notranslate">object</span> ) oraz tego, czy się pokrywają, czy nie. Zauważ, że jeśli jedna lub druga instancja w kolizji nie ma przypisanej maski (lub maska <span class="notranslate">sprite</span> jest ustawiona na zero), to <em>nawet jeśli coś rysuje</em>, nie zostaną wykryte żadne kolizje.</p>
      <p class="dropspot">Jeśli masz włączoną <strong>fizykę </strong>, wtedy kolizja będzie oparta na typie <strong>kształtu</strong> kolizji<em>(Fixture</em>), który zdefiniowałeś dla <span class="notranslate">object</span> w jego właściwościach fizyki, podobnie jak jego reakcja na kolizję. Oznacza to, że możesz nie potrzebować żadnego kodu do obsługi kolizji, ale zdarzenie to będzie musiało <em>zawierać co najmniej komentarz </em>, aby kolizje zostały wykryte.</p>
      <p class="dropspot">Na koniec należy zauważyć, że wszystkie kolizje będą obliczane raz na krok gry, zanim zostanie wywołane zdarzenie kolizji, tak więc gdy zdarzenie kolizji zostanie uruchomione, wszystkie kolizje zostaną już obliczone i wstępnie przypisane. Oznacza to, że jeśli utworzysz instancję w tym zdarzeniu, a następnie spróbujesz sprawdzić, czy doszło do kolizji, kolizja nie zostanie wykryta ani rozwiązana aż do następnej <a class="glossterm" data-glossterm="iteracja" href="#">iteracji</a> gry <span class="notranslate">loop</span>.</p>
      <p class="dropspot"> </p>
      <p class="dropspot"> </p>
    </div>
    <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down14" href="#">Klawiatura,</a>  <img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down14" href="#">Prasa do klawiatury,</a>  <img> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down14" href="#">Odblokowanie klawiatury</a></p>
    <div class="droptext" data-targetname="drop-down14">
      <p class="dropspot">Umożliwienie graczowi kontrolowania różnych aspektów gry jest bardzo ważne. W tym celu <span data-keyref="GameMaker Name">GameMaker</span> udostępnia bardzo obszerną listę zdarzeń klawiaturowych, które można wykorzystać w każdej z trzech głównych kategorii klawiatur. W przypadku kategorii Klawiatura ogólna, jest ona wyzwalana w sposób ciągły co krok, dopóki wybrany klawisz jest wciśnięty, natomiast zdarzenia z kategorii Naciśnięcie i zwolnienie będą wyzwalane tylko raz, gdy klawisz zostanie wciśnięty lub zwolniony.</p>
      <p class="dropspot">Należy zauważyć, że zdarzenia klawiaturowe są wyzwalane we wszystkich aktywnych instancjach w witrynie <span class="notranslate">room</span> za każdym razem, gdy zostanie użyty klawisz, ale zareagują tylko te, które mają zdefiniowane zdarzenie dla danego klawisza. Można utworzyć wiele zdarzeń klawiaturowych w dowolnej witrynie <span class="notranslate">object</span>, a instancje tej witryny <span class="notranslate">object</span> zareagują na nie wszystkie podczas gry.</p>
      <p class="dropspot">Po dodaniu dowolnego zdarzenia klawiaturowego do witryny <span class="notranslate">object</span> zostanie wyświetlone menu zdarzeń podrzędnych klawiatury, w którym można określić klawisz, który ma być sprawdzany:</p>
      <p class="dropspot"><img>Większość z nich jest dość oczywista, ale omówmy pokrótce poszczególne sekcje - na górze mamy klawisze strzałek, następnie najczęściej używane klawisze modyfikatorów, potem resztę klawiatury (podzieloną na dalsze podsekcje, aby można było uzyskać dokładny wymagany klawisz, np. <img> lub <img>), a na końcu dwa bardzo specjalne zdarzenia podrzędne, <strong>No Key</strong> i <strong>Any Key</strong>. Jak sugerują ich nazwy, są to zdarzenia podrzędne, które sprawdzają, czy nie został naciśnięty <em>żaden </em>klawisz lub czy został naciśnięty <em>dowolny </em>klawisz. Należy pamiętać, że klawisze klawiatury numerycznej wywołują odpowiednie zdarzenia tylko wtedy, gdy włączona jest funkcja <strong>Number Lock </strong>.</p>
      <p class="dropspot">Zdarzenia <strong>Naciśnięcie </strong>i <strong>Zwolnienie </strong>klawisza są prawie dokładnie takie same jak zwykłe zdarzenia klawiatury, z tą różnicą, że zamiast być wyzwalane w sposób ciągły, są wyzwalane tylko raz. Gdy klawiatura po raz pierwszy zarejestruje, że klawisz został naciśnięty, wygeneruje zdarzenie <strong>Naciśnięcie</strong> klawisza (oraz zwykłe zdarzenie Klawiatura), a za pierwszym razem, gdy klawisz nie będzie już wykrywany jako naciśnięty, wygeneruje pojedyncze zdarzenie <strong>Zwolnienie</strong> klawisza.</p>
      <p class="dropspot"> </p>
      <p class="dropspot"> </p>
    </div>
    <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down16" href="#">Mysz</a></p>
    <div class="droptext" data-targetname="drop-down16">
      <p class="dropspot">Kategoria Mysz jest podzielona na serię zdarzeń, które można wybrać, aby uzyskać bardziej precyzyjną kontrolę nad tym, co dzieje się w grze. Tutaj można zobaczyć, jakie dokładnie są to zdarzenia:</p>
      <p class="dropspot"><img>Zdarzenia związane z lewym <img>, prawym <img> i środkowym <img> przyciskiem ( <strong>normalne</strong>, <strong>wciśnięte </strong>lub <strong>zwolnione</strong>) działają na maskę instancji, która ma zdarzenie. Oznacza to, że <span data-keyref="GameMaker Name">GameMaker</span> sprawdzi pozycję myszy w witrynie <span class="notranslate">room</span>, gdy zostaną użyte te przyciski, względem masek kolizji instancji, które mają zdarzenie myszy. Jeśli dojdzie do &quot;kolizji&quot; z <a class="glossterm" data-glossterm="ramka ograniczająca" href="#">bounding boxem</a> instancji, zdarzenie zostanie wywołane, więc upewnij się, że każda instancja z tymi zdarzeniami ma <span class="notranslate">sprite</span> z poprawną maską kolizji lub że <span class="notranslate">object</span> ma maskę <span class="notranslate">sprite</span> wybraną we właściwościach <span class="notranslate">object</span>. Jak sugerują ich nazwy, zdarzenia te będą wyzwalane albo jednorazowo, gdy wybrany przycisk myszy zostanie po raz pierwszy naciśnięty lub zwolniony, albo w sposób ciągły w każdym kroku, gdy przycisk jest przytrzymywany. </p>
      <p class="dropspot">Zdarzenia wejścia i wyjścia myszy są również podobne do zdarzeń przycisków, ponieważ ich działanie również opiera się na masce instancji, ale tym razem są one wyzwalane, gdy mysz po raz pierwszy &quot;wejdzie&quot; (dotknie) instancji lub gdy &quot;wyjdzie&quot; (przestanie dotykać) instancji. Zdarzenia te nie są jednak ciągłe i są wyzwalane tylko raz za każdym razem, gdy mysz wejdzie lub opuści instancję <span class="notranslate">object</span> - są więc idealną metodą tworzenia np. przycisków, które mają się zmieniać po najechaniu na nie myszą, a następnie wracać do normalnego stanu po usunięciu myszy.</p>
      <p class="dropspot">Na koniec mamy jeszcze jedną sekcję zdarzeń myszy, która nosi nazwę Mysz <strong>globalna</strong>. W tym podmenu znajdziesz wybór zdarzeń, które służą do rejestrowania zdarzeń myszy w instancjach, nawet jeśli mysz nie znajduje się nad nimi lub nawet w ich pobliżu. Są to zdarzenia, które są generowane dla <em>wszystkich </em>instancji i jeśli dla danego zdarzenia są zdefiniowane akcje lub kod, to zostaną one uruchomione, niezależnie od położenia myszy w grze <span class="notranslate">room</span>.</p>
      <p class="dropspot">Należy pamiętać, że w urządzeniach przenośnych lub z ekranem dotykowym lewy przycisk myszy <img> może być również używany do sprawdzania, czy na ekranie dotykowym nie ma tabulatora z palcem, a prawy przycisk myszy <img> jest wyzwalany przez podwójne stuknięcie w ekran (to zachowanie można zmienić za pomocą kodu).</p>
      <p class="dropspot"> </p>
      <p class="dropspot"> </p>
    </div>
    <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down18" href="#">Gesty</a></p>
    <div class="droptext" data-targetname="drop-down18">
      <p class="dropspot">Jest to zdarzenie, które zostanie wywołane przez użytkownika dotykającego ekranu (na urządzeniach mobilnych) lub klikającego i poruszającego myszą (na wszystkich innych platformach). Zdarzenia te są podobne do zdarzeń myszy, ponieważ istnieją wersje zwykłe oraz wersje <em>globalne</em>. Zwykłe wersje tych zdarzeń są wyzwalane tylko wtedy, gdy dotknięcie nastąpi na instancji, która ma stronę <span class="notranslate">sprite</span> (lub maskę), a dotknięcie nastąpi w jej <a class="glossterm" data-glossterm="ramka ograniczająca" href="#">polu ograniczającym</a>. Natomiast globalne wersje tych zdarzeń zostaną wywołane przez użytkownika dotykającego <em>dowolnego miejsca </em>na ekranie.</p>
      <p class="dropspot">Zdarzenia związane z gestami pozwalają wykryć następujące elementy:</p>
      <ul class="dropspotlist">
        <li class="dropspot"><img> <strong>stuknięcia - </strong> gdy użytkownik klika/dotyka i szybko zwalnia przycisk</li>
        <li class="dropspot"><img> <strong>przeciąganie - </strong> gdy użytkownik dotknie/kliknie i przytrzyma, a następnie przesunie palec/kursor</li>
        <li class="dropspot"><img> kliknięcia <strong>- </strong> gdy użytkownik przesuwa i zwalnia dotyk/kliknięcie jednym ruchem</li>
        <li class="dropspot"><img> <strong>uszczypnięcia - </strong> gdy użytkownik trzyma dwa palce na ekranie, a następnie przesuwa je razem/oddziela od siebie</li>
        <li class="dropspot"><img> <strong>obraca - </strong> gdy użytkownik trzyma dwa palce na ekranie, a następnie obraca je wokół punktu</li>
      </ul>
      <p class="dropspot"><img>Różne zdarzenia będą zawsze zawierać mapę DS o nazwie &quot;<span class="inline">event_data</span>&quot;, która będzie zawierać pewną liczbę par klucz/wartość z danymi dotyczącymi pozycji i ruchu dotknięcia/kliknięcia. Szczegółowe informacje o wszystkich dostępnych zdarzeniach podrzędnych i sposobie ich działania można znaleźć w następującej sekcji:</p>
      <ul class="dropspotlist">
        <li class="dropspot"><a href="Gesture_Events.htm">Wydarzenie "Gest</a></li>
      </ul>
      <p class="dropspot"> </p>
      <p class="dropspot"> </p>
    </div>
    <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down19" href="#">Inne</a></p>
    <div class="droptext" data-targetname="drop-down19">
      <p class="dropspot">Istnieje wiele specjalnych zdarzeń, z których można korzystać podczas tworzenia gier w programie <span data-keyref="GameMaker Name">GameMaker</span>. Są one w większości zgrupowane w ramach zdarzenia Other (Inne) i można je wybierać z menu podręcznego, które pojawia się po wybraniu tego zdarzenia. Poniżej znajduje się obraz wszystkich innych zdarzeń:</p>
      <p class="dropspot"><img>Więcej informacji o każdym z wydarzeń przedstawionych na powyższej ilustracji można znaleźć w poniższej sekcji:</p>
      <ul class="dropspotlist">
        <li class="dropspot"><a href="Other_Events.htm">Pozostałe wydarzenia</a></li>
      </ul>
      <p class="dropspot"> </p>
    </div>
    <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down20" href="#">Rysuj</a></p>
    <div class="droptext" data-targetname="drop-down20">
      <p class="dropspot">Ta kategoria zdarzeń decyduje o tym, co widać na ekranie po uruchomieniu gry, i jest podzielona na różne zdarzenia:</p>
      <p class="dropspot"><img>Jak widać, kategoria zdarzeń rysowania zawiera wiele różnych typów zdarzeń. Zdarzenia Draw <strong>Begin</strong>, <strong>Draw </strong>i <strong>Draw End</strong> są &quot;standardowymi&quot; zdarzeniami rysowania, z których prawdopodobnie będziesz korzystać najczęściej. Domyślnie główne zdarzenie Draw jest zawsze wywoływane dla każdej instancji, niezależnie od tego, czy ma ona adres <span class="notranslate">sprite</span>, czy nie, choć jeśli <span class="notranslate">flag</span> instancja jest niewidoczna, zdarzenie to nie zostanie wywołane (pamiętaj o tym, jeśli masz jakąś logikę gry w zdarzeniu draw niewidocznego obiektu <span class="notranslate">object</span>, ponieważ nie zostanie ona uruchomiona). Zdarzenie main draw jest także tym, w którym <span data-keyref="GameMaker Name">GameMaker</span> domyślnie rysuje instancję <span class="notranslate">sprite</span>, jeśli w zdarzeniu nie ma żadnego kodu ani akcji (tzn. nie dodałeś go do listy zdarzeń dla <span class="notranslate">object</span>). Domyślne rysowanie używa adresu <span class="notranslate">sprite</span> powiązanego z instancją i będzie ją rysować z wszelkimi transformacjami ustawionymi w kodzie lub zastosowanymi akcjami.</p>
      <p class="dropspot">Standardowe zdarzenia rysowania są rysowane <em>przed </em>zdarzeniami Rysuj <strong>GUI </strong>i <em>między </em>zdarzeniami <strong>Przed </strong>rysowaniem i <strong>Po </strong>rysowaniu, co oznacza, że wszystko, co zostanie narysowane w tym zdarzeniu, jest rysowane pod zdarzeniem Rysuj <strong>GUI </strong>, niezależnie od warstwy (tzn. wszystko, co zostanie narysowane w zdarzeniu Rysuj GUI, będzie zawsze rysowane nad wszystkim, co zostanie narysowane w zwykłym zdarzeniu rysowania, niezależnie od kolejności warstw).</p>
      <p class="dropspot">Powyżej przedstawiono ogólny zarys działania zdarzeń losowania, natomiast szczegółowe informacje na temat wszystkich dostępnych zdarzeń podrzędnych można znaleźć w następującej sekcji:</p>
      <ul class="dropspotlist">
        <li class="dropspot"><a href="Draw_Events.htm">Wydarzenie losowania</a></li>
      </ul>
      <p> </p>
      <p> </p>
      <p class="dropspot"> </p>
    </div>
    <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down21" href="#">Asynchroniczne</a></p>
    <div class="droptext" data-targetname="drop-down21">
      <p class="dropspot">Ta kategoria zdarzeń jest szczególna, ponieważ zdarzenia w niej zawarte nie są domyślnie wywoływane przez program <span data-keyref="GameMaker Name">GameMaker</span>, ale raczej przez zakończenie jakiejś innej akcji, na przykład załadowanie pliku lub odpowiedź z witryny <span class="notranslate">server</span>. Kategoria ta jest podzielona na następujące zdarzenia:</p>
      <p class="dropspot"><img alt="Object Editor Events View" class="center" src="../../assets/Images/Asset_Editors/Editor_Objects_Events.png"/></p>
      <p class="dropspot">Powiedzmy, że chcesz dodać plik graficzny do programu <span data-keyref="GameMaker Name">GameMaker</span>. Cóż, zakodowałbyś to w innym zdarzeniu (być może w zdarzeniu Create Event) na stronie <span class="notranslate">object</span>, a następnie kazałbyś tej stronie <span class="notranslate">object</span> narysować pasek ładowania podczas oczekiwania (na przykład), <a class="glossterm" data-glossterm="callback" href="#">wywołując</a> odpowiednie zdarzenie asynchroniczne aż do <a class="glossterm" data-glossterm="callback" href="#">wywołania zwrotnego</a>, które powie <span data-keyref="GameMaker Name">GameMakerowi</span>, że plik został załadowany. Dane zwrócone w tym zdarzeniu można następnie wykorzystać do innych celów, np. zmiany adresu <span class="notranslate">room</span> lub zakupu przedmiotu.</p>
      <p class="dropspot">Powyżej przedstawiono ogólny zarys działania zdarzenia asynchronicznego, natomiast szczegółowe informacje na temat wszystkich dostępnych zdarzeń podrzędnych można znaleźć w następującej sekcji:</p>
      <ul class="dropspotlist">
        <li class="dropspot"><a href="Async_Events.htm">Lista zdarzeń asynchronicznych</a></li>
      </ul>
      <p class="dropspot"> </p>
    </div>
    <p> </p>
    <p>Należy również pamiętać, że zdarzenia można nazywać, a przynajmniej nadawać im krótki tekst opisowy, który będzie wyświetlany obok nich w Edytorze zdarzeń. Aby to zrobić, wystarczy w pierwszym wierszu edytora kodu zdarzenia (jeśli używasz kodu <span data-keyref="GML_Code">GML</span>) dodać poniższy tekst:</p>
    <p class="code">/// @description Your text here</p>
    <p>Coś takiego może się znaleźć na przykład w zdarzeniu <strong>Alarm </strong>:</p>
    <p class="code">/// @description This is the AI Fight alarm</p>
    <p>Teraz w Edytorze zdarzeń zobaczysz to:</p>
    <p><img alt="Object Editor Events List" class="center" src="../../assets/Images/Asset_Editors/Editor_Objects_EventList.png"/></p>
    <p>Dla użytkowników <span data-keyref="GML_Visual">GML Visual</span> dodanie komentarza wymaga użycia akcji <strong>Execute Code</strong>, którą należy umieścić na samej górze listy akcji dla danego zdarzenia, przed wszystkimi innymi. Po dodaniu tej akcji należy nadać jej tę samą linię kodu, która została pokazana powyżej, aby nazwać zdarzenie, np:</p>
    <p><img>Dodatkowe informacje na temat niektórych z powyższych imprez oraz ogólny porządek przebiegu imprezy można znaleźć w poniższych sekcjach:</p>
    <ul class="colour">
      <li><a href="Event_Order.htm">Kolejność zdarzeń</a></li>
      <li><a href="Other_Events.htm">Pozostałe wydarzenia</a></li>
      <li><a href="Draw_Events.htm">Wydarzenia związane z losowaniem</a></li>
      <li><a href="Async_Events.htm">Zdarzenia asynchroniczne</a></li>
      <li><a href="Gesture_Events.htm">Wydarzenia związane z gestami</a></li>
    </ul>
    <p> </p>
    <p> </p>
    <p> </p>
    <div class="footer">
      <div class="buttons">
        <div class="clear">
          <div style="float:left">Powrót: <a href="../Objects.htm">Redaktor <span class="notranslate">Object</span> </a></div>
          <div style="float:right">Następny: Obiekty macierzyste</div>
        </div>
      </div>
      <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Wszystkie prawa zastrzeżone.</span></h5>
    </div>
    <!-- KEYWORDS
Object Events
Named Events
--><!-- TAGS
object_events
--></body>
</html>