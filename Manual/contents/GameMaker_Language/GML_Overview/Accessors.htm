<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Akcesoria</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
  <script src="../../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page outlining the different Accessors" />
  <meta name="rh-index-keywords" content="Accessors" />
  <meta name="search-keywords" content="Accessors,@,[| ],[@ ],[# ],[? ],grid accessor,list accessor,map accessor,array accessor" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Akcesoria</h1>
  <p>Strona <span class="notranslate">GameMaker Language</span> (<span class="notranslate">GML</span>) pozwala także na dostęp do pewnych <a href="../GML_Reference/Data_Structures/Data_Structures.htm">struktur danych</a> i <a href="Arrays.htm">tablic</a> za pomocą wyrażeń logicznych zwanych <b>accessorami</b>. Struktura jest podobna do normalnej pracy z tablicą, z tą różnicą, że używamy <em>symbolu identyfikatora</em> przed pierwszym argumentem, aby poinformować <span data-keyref="GameMaker Name">GameMakera</span>, że pracujemy nad (wcześniej utworzoną) strukturą danych lub literałem tablicy.</p>
  <p> </p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down10" href="#">Listy DS [| ]</a></p>
  <div class="droptext" data-targetname="drop-down10">
    <p class="dropspot">Składnia <a href="../GML_Reference/Data_Structures/DS_Lists/DS_Lists.htm">list DS</a> jest następująca:</p>
    <p class="code">list_index[| index]</p>
    <p class="dropspot">Tak więc po utworzeniu listy za pomocą strony <span class="inline">ds_list_create()</span> należy użyć indeksu listy (przechowywanego w zmiennej), aby się do niej odwołać, przy czym wartość &quot;index&quot; oznacza pozycję na liście, którą należy ustawić lub dodać. Na przykład poniższy kod tworzy listę, a następnie dodaje 10 wpisów, ustawiając każdy z nich na losową liczbę od 0 do 9:</p>
    <p class="code">ds = ds_list_create();<br />
      var index = 0;<br />
      repeat(10)<br />
      {<br />
          ds[| index++] = irandom(9);<br />
      }</p>
    <p class="dropspot">Zwróć uwagę, że jeśli używasz wyrażenia do dodania odwołania do indeksu, który ma już wartość, poprzednia wartość zostanie zastąpiona, a nie dodany zostanie kolejny indeks do listy. Aby dodać kolejne wpisy, należałoby znać rozmiar listy ds_list i dodać je na końcu. Warto również zauważyć, że można ustawić indeks listy <i>większy</i> niż rozmiar listy, do której się odwołujemy, a to spowoduje ustawienie tej wartości, jednocześnie rozwijając listę i inicjalizując wszystkie pozycje na liście do podanego indeksu jako 0.</p>
    <p class="dropspot">Po utworzeniu struktury listy i wypełnieniu jej danymi, aby pobrać wartości z listy, należy wykonać następujące czynności:</p>
    <p class="code">value = ds[| 5];</p>
    <p class="dropspot">Powyższe polecenie pobierze wartość z pozycji 5 (szósty indeks, ponieważ listy zaczynają się od 0) i zapisze ją w zmiennej. Jeśli podasz pozycję spoza rozmiaru listy, to zwrócona zostanie wartość <span class="inline">undefined</span>, którą możesz sprawdzić za pomocą funkcji <a href="../GML_Reference/Variable_Functions/is_undefined.htm"><span class="inline">is_undefined()</span></a>.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down13" href="#">Mapy DS [? ]</a></p>
  <div class="droptext" data-targetname="drop-down13">
    <p class="dropspot">Składnia <a href="../GML_Reference/Data_Structures/DS_Maps/DS_Maps.htm">map DS</a> jest następująca:</p>
    <p class="code">map_index[? key]</p>
    <p class="dropspot">Po utworzeniu mapy za pomocą <span class="inline">ds_map_create()</span>, w celu odwołania się do niej należy użyć indeksu mapy zapisanego w zmiennej, przy czym wartość &quot;key&quot; oznacza klucz mapy, który należy ustawić lub uzyskać. Na przykład poniższy kod tworzy mapę, a następnie dodaje do niej kilka wpisów, używając tej składni:</p>
    <p class="code">ds = ds_map_create();<br />
      ds[? &quot;Name&quot;] = &quot;Hamish&quot;;<br />
      ds[? &quot;Company&quot;] = &quot;MacSeweeny Games&quot;;<br />
      ds[? &quot;Game&quot;] = &quot;Catch The Haggis&quot;;</p>
    <p class="dropspot">Należy zauważyć, że jeśli mapa zawiera już tę samą wartość klucza, którą próbujemy dodać, nie zostanie utworzony duplikat klucza z nową wartością, lecz poprzednia wartość zostanie zastąpiona.</p>
    <p class="dropspot">Po utworzeniu struktury mapy i wypełnieniu jej danymi, aby uzyskać wartości z określonego klucza mapy, należy wykonać coś takiego:</p>
    <p class="code">value = ds[? &quot;Name&quot;];</p>
    <p class="dropspot">Powyższe polecenie pobierze wartość z klucza &quot;Nazwa&quot; i zapisze ją w zmiennej, ale należy pamiętać, że jeśli podany klucz nie istnieje w mapie DS, to zwrócona wartość będzie miała postać <span class="inline">undefined</span>. Można to sprawdzić za pomocą funkcji <a href="../GML_Reference/Variable_Functions/is_undefined.htm"><span class="inline">is_undefined()</span></a>.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down14" href="#">DS Grids [# ]</a></p>
  <div class="droptext" data-targetname="drop-down14">
    <p class="dropspot">Składnia dla <a href="../GML_Reference/Data_Structures/DS_Grids/DS_Grids.htm">siatki DS</a> jest następująca:</p>
    <p class="code">grid_index[# xpos, ypos]</p>
    <p class="dropspot">Po utworzeniu siatki za pomocą funkcji <span class="inline">ds_grid_create()</span> należy użyć indeksu siatki przechowywanego w zmiennej, aby się do niej odwołać, przy czym &quot;xpos&quot; i &quot;ypos&quot; oznaczają pozycję w siatce w celu uzyskania lub ustawienia wartości. Na przykład w poniższym kodzie utworzono siatkę, wyczyszczono ją do wartości 0, a następnie dodano do niej kilka wpisów:</p>
    <p class="code">ds = ds_grid_create();<br />
      ds_grid_clear(ds, 0);<br />
      var gw = ds_grid_width(ds) - 1;<br />
      var gh = ds_grid_height(ds) - 1;<br />
      repeat(10)<br />
      {<br />
          var xx = irandom(gw);<br />
          var yy = irandom(gh);<br />
          if (ds[# xx, yy] == 0)<br />
          {<br />
              ds[# xx, yy] = 1;<br />
          }<br />
      }</p>
    <p class="dropspot">Po utworzeniu struktury siatki i wypełnieniu jej danymi, aby uzyskać wartości z określonej pozycji siatki, należy wykonać następujące czynności:</p>
    <p class="code">value = ds[# mouse_x div 16, mouse_y div 16];</p>
    <p class="dropspot">Powyższe działanie spowoduje pobranie wartości z podanej ds_grid na podstawie pozycji myszy (podzielonej przez szerokość &quot;komórki&quot; w <span class="notranslate">room</span>, aby uzyskać prawidłowe położenie). Jeśli podasz pozycję, która znajduje się poza granicami siatki, zwrócona zostanie wartość <span class="inline">undefined</span>, którą można sprawdzić za pomocą funkcji <a href="../GML_Reference/Variable_Functions/is_undefined.htm"><span class="inline">is_undefined()</span></a>.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down15" href="#">Tablice [@ ]</a></p>
  <div class="droptext" data-targetname="drop-down15">
    <p class="dropspot">Ten accessor jest używany tylko wtedy, gdy włączona jest <a href="../../Settings/Game_Options.htm">opcja Copy on Write</a>.</p>
    <p class="dropspot">Tablice posiadają również własne accessory, które działają w podobny sposób, jak te wymienione powyżej dla struktur danych. Jednak dostęp do tablic ma jeszcze jedną ciekawą właściwość, a mianowicie pozwala na modyfikowanie tablicy z poziomu <a href="Script_Functions.htm">funkcji skryptu</a> lub <a href="Method_Variables.htm"><span class="notranslate">method</span></a> bez konieczności jej kopiowania. Gdy przekazujemy tablicę do funkcji, jest ona przekazywana <strong>przez referencję</strong>, co oznacza, że sama tablica nie jest <strong>przekazywana</strong> do <span class="notranslate">script</span>, lecz po prostu jest do niej odwoływana w celu uzyskania danych. W normalnej sytuacji, jeśli trzeba by zmienić tablicę, należałoby ją <em>skopiować </em>na stronę <span class="notranslate">script</span>, a następnie przekazać z powrotem (zwrócić) skopiowaną tablicę, aby oryginalna tablica została zaktualizowana. Może to powodować kosztowne koszty przetwarzania, dlatego zamiast tego można skorzystać z narzędzia dostępu, które zmieni oryginalną tablicę <em>bezpośrednio </em>, bez konieczności jej kopiowania. Jak to działa, można zobaczyć w poniższych przykładach.</p>
    <p class="dropspot">Składnia dla tablic, przy użyciu narzędzia dostępu <span class="inline">@</span>, jest następująca:</p>
    <p class="code">array[@ i]</p>
    <p class="dropspot">Po utworzeniu tablicy w instancji można przekazać ją do <span class="notranslate">script</span> przez referencję i użyć akcesora <span class="inline">@</span>, aby ją bezpośrednio zmienić. Na przykład można utworzyć tablicę i wywołać funkcję w następujący sposób:</p>
    <p class="code">array[99] = 0;<br />
      array_populate(array);</p>
    <p class="dropspot">Sama funkcja będzie miała następującą postać:</p>
    <p class="code">function array_populate(_array)<br />
      {<br />
          var a = _array; var i = 0; repeat(25)<br />
          {<br />
              i = irandom(99);<br />
              while (a[i] != 0)<br />
              {<br />
                  i = irandom(99);<br />
              }<br />
              a[@ i] = 100;<br />
          }<br />
      }</p>
    <p class="dropspot">Funkcja ta wybiera 25 losowych pozycji w tablicy i ustawia wartość wybranej pozycji tablicy na 100.</p>
    <p class="dropspot">Oczywiście, gdy funkcja <strong>kopiowania przy zapisie</strong> jest wyłączona, dostęp do <span class="inline">@</span> nie jest wymagany.</p>
    <p class="note"><span class="note">UWAGA</span> Podczas pracy z tablicą <span class="inline">argument[n]</span> w funkcjach skryptu nie można używać akcesora tablicy <span class="inline">@</span>.</p>
    <p class="dropspot"> </p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down16" href="#">Struktury [$ ]</a></p>
  <div class="droptext" data-targetname="drop-down16">
    <p class="dropspot"><span>Składnia <a href="Structs.htm">struktów</a> jest następująca</span></p>
    <p class="code">struct[$ &quot;name&quot;]</p>
    <p class="dropspot">Dostęp ten jest w zasadzie opakowaniem funkcji <span><a href="../GML_Reference/Variable_Functions/variable_struct_get.htm"><span class="inline">variable_struct_get()</span></a> i <a href="../GML_Reference/Variable_Functions/variable_struct_set.htm"><span class="inline">variable_struct_set()</span></a>, z których można korzystać podobnie jak z dostępu do mapy DS. Na przykład, jeśli utworzyłeś stronę <span class="notranslate">struct</span> i chcesz pobrać wartość ze zmiennej o nazwie &quot;my_health&quot;, wykonaj następujące czynności:</span></p>
    <p class="code">var _hp = struct[$ &quot;my_health&quot;];</p>
    <p class="dropspot">Jak widać, nie podajemy samej zmiennej, ale raczej <em>łańcuch</em> znaków zawierający tę zmienną. Zauważ, że jeśli na stronie <span class="notranslate">struct</span> nie ma zmiennej o podanej nazwie, to accessor zwróci wartość <span class="inline">undefined</span>.</p>
    <p class="dropspot">Aby ustawić zmienną w witrynie <span class="notranslate">struct</span>, należy wykonać następujące czynności</p>
    <p class="code">struct[$ &quot;my_score&quot;] = 100;</p>
    <p class="dropspot">Podobnie jak w przypadku pobierania wartości, podajesz nazwę zmiennej, którą chcesz ustawić jako <span class="notranslate">string</span>, a zostanie ona ustawiona na podaną wartość. Jeśli użyta nazwa zmiennej nie istnieje w <span class="notranslate">struct</span>, to zostanie ona utworzona i ustawiona na podaną wartość.</p>
    <p class="dropspot"> </p>
  </div>
  <p> </p>
  <p>Ważną cechą akcesorów jest to, że można je <i>łączyć w łańcuchy</i>. Oznacza to, że jeśli masz kilka zagnieżdżonych struktur danych i/lub tablic, nie musisz już używać wielu funkcji, aby uzyskać dostęp do wartości, która znajduje się głęboko w zagnieżdżonej strukturze. Na przykład, powiedzmy, że mamy tablicę, a każdy element w tablicy jest listą DS, jak poniżej:</p>
  <p class="code">array = array_create(3);<br />
    for (var i = 0; i &lt; 3; ++i;)<br />
    {<br />
        array[i] = ds_list_create();<br />
        switch(i)<br />
        {<br />
            case 0:<br />
                with (obj_Wall) ds_list_add(array[i], id);<br />
            break;<br />
    <br />
            case 1:<br />
                with (obj_Door) ds_list_add(array[i], id);<br />
            break;<br />
    <br />
            case 2:<br />
                with (obj_Chest) ds_list_add(array[i], id);<br />
            break;<br />
        }<br />
    }
  </p>
  <p>W powyższym kodzie utworzyliśmy tablicę składającą się z 3 elementów i przypisaliśmy każdej z nich listę DS, a następnie wypełniliśmy poszczególne listy identyfikatorami instancji różnych <span class="notranslate">objects</span> w grze. Teraz, aby uzyskać dostęp do identyfikatora na jednej z list, możemy wykonać następujące czynności:</p>
  <p class="code">var _list = array[0];<br />
    var _id = ds_list_find_value(_list, 0);</p>
  <p>Można jednak zrobić to samo, używając łańcuchowych accessorów, w znacznie czystszy sposób i przy użyciu mniejszej ilości kodu:</p>
  <p class="code">var _id = array[0][| 0];</p>
  <p>W ten sposób można łączyć ze sobą wiele akcesorów i mogą one być różnych typów, aby uzyskać dostęp do informacji przechowywanych w każdej części zagnieżdżonej struktury. Oto kilka kolejnych przykładów:</p>
  <p class="code">// Access a grid that has been added to a list that is part of a map:<br />
    var _a = data[? &quot;lists&quot;][| 0][# 0, 0];<br />
    <br />
    // Access an array nested in a list from a script and modify it:<br />
    data[| 0][@ 10] = 100;<br />
    <br />
    // Access a map nested in a grid nested in a list nested in an array:<br />
    data[0][| 10][# 3, 4][? &quot;key&quot;] = &quot;hello world&quot;;
  </p>
  <p>Używanie łańcuchowych akcesorów nie tylko oznacza, że można pisać bardziej zwarty kod, ale także pozwala na użycie iteracji (na przykład przy użyciu pętli <a href="Language_Features/for.htm"><span class="inline">for</span></a> pętli) oraz innych technik umożliwiających dostęp do danych w czystszy i bardziej intuicyjny sposób.</p>
  <p>Warto zauważyć, że używając w ten sposób akcesorów, należy zawsze korzystać z akcesora <span class="inline">@</span> dla tablic, ponieważ w przeciwnym razie spowoduje to dodanie dodatkowego narzutu do wykonywanych działań. Jak wspomniano powyżej, tablice są domyślnie przekazywane do funkcji przez referencję, a następnie przy modyfikacji są kopiowane przy zapisie. Jeśli jednak tablica jest częścią łańcucha, to poprzedni element łańcucha zostanie zaktualizowany skopiowaną tablicą, a &quot;oryginał&quot; zostanie usunięty. Na przykład, wykonując coś takiego:</p>
  <p class="code">// In an object event<br />
    data[| 0][0] = 100;<br />
    <br />
    // In a function<br />
    data[| 0][0] = 200;
  </p>
  <p>daje takie same rezultaty jak to:</p>
  <p class="code">// In an object event<br />
    data[| 0][0] = 100;<br />
    <br />
    // In a function<br />
    data[| 0][@ 0] = 200;
  </p>
  <p>Drugi przykład jest jednak lepszy, ponieważ działa bez zbędnego narzutu związanego z kopiowaniem całej tablicy.</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Powrót: <a href="GML_Overview.htm">Przegląd GML</a></div>
        <div style="float:right">Następny: <a data-xref="{title}" href="Language_Features.htm">Cechy języka</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Wszystkie prawa zastrzeżone.</span></h5>
  </div>
  <!-- KEYWORDS
div
mod
bitwise operators
bitshift
and
or
xor 
&amp;&amp;
||
^^
%
|
&amp;
^
&lt;&lt;
&gt;&gt;
bitwise or
bitwise and
bitwise xor
bitshift left
bitshift right
&lt;
&lt;=
==
!=
&gt;
&gt;=
++
$
hexadecimal
-->
  <!-- TAGS
expressions_operators
-->
</body>
</html>