<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Tablice</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
  <script src="../../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page outlining Arrays" />
  <meta name="rh-index-keywords" content="Arrays" />
  <meta name="search-keywords" content="Arrays" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Tablice</h1>
  <p>Tablice mogą być niezwykle użyteczne i są istotną częścią tworzenia gier. Jest to rodzaj zmiennej, która może przechowywać wiele wartości jako &quot;listę&quot; - rozważ poniższy kod:</p>
  <p class="code">numbers = [ 0, 1, 2, 3, 4, 5 ];<br />
    <br />
    fruits = [ &quot;Apples&quot;, &quot;Oranges&quot;, &quot;Mangoes&quot; ];
  </p>
  <p>Używając składni <span class="inline2">[element, element, element],</span> tworzymy tablicę <span class="inline2">,</span> która jest przechowywana w zmiennej. Dostęp do elementów przechowywanych w tablicy można później uzyskać za pośrednictwem tej zmiennej, używając liczby całkowitej, zaczynając od <span class="inline">0</span>, którą umieszcza się wewnątrz nawiasów <span class="inline2">[]</span>:</p>
  <p class="code">first_fruit = fruits[ 0 ];<br />
    second_fruit = fruits[ 1 ];<br />
    // ...and so on.</p>
  <p><label for="aone">Podstawowa tablica ma jeden <strong>wymiar</strong>, ale można też tworzyć tablice o więcej niż jednym <strong>wymiarze</strong>. W poniższych sekcjach wyjaśniono oba typy tablic:</label></p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">Tablice jednowymiarowe</a></p>
  <div class="droptext" data-targetname="drop-down1">
    <p class="dropspot">Zanim przejdziemy dalej, wyjaśnijmy, czym właściwie jest tablica i jak jest zbudowana. Tablica to po prostu <a href="Data_Types.htm">typ danych</a>, który jest przypisany do zmiennej i może zawierać nie tylko jedną, ale wiele wartości. Na poniższym rysunku przedstawiono schemat podstawowej tablicy:</p>
    <p class="dropspot"><img class="center" src="../../assets/Images/Scripting_Reference/GML/Overview/1DArrayExample.png" /></p>
    <p class="dropspot">Jest to tzw. tablica <strong>1D</strong> (jednowymiarowa). Jak widać, tablica jest przechowywana w zmiennej &quot;<span class="inline">a</span>&quot; i zawiera wiele wartości. Aby uzyskać dostęp do tablicy, należy wykonać następujące czynności:</p>
    <p class="code">var _val = a[0];<br />
      show_debug_message(_val);</p>
    <p class="dropspot">Powyższy kod pobiera wartość z pozycji 0 tablicy &quot;<span class="inline">a</span>&quot;, a następnie wypisuje ją na konsolę, co - na podstawie zawartości tablicy widocznej na powyższym rysunku - dałoby wynik 125. Gdybyś wykonał następujące czynności:</p>
    <p class="code">var _val = a[3];<br />
      show_debug_message(_val);</p>
    <p class="dropspot">Na wyjściu pojawi się napis &quot;Cześć!&quot;.</p>
    <p class="dropspot">Jak widać, nadajemy tablicy nazwę zmiennej, a następnie wartość w nawiasach kwadratowych <span class="inline">[]</span>, gdzie wartość jest pozycją w tablicy, z której chcemy pobrać dane. Zasadniczo więc tablica jest pojemnikiem zawierającym pewną liczbę gniazd do przechowywania wartości, a każda pozycja w pojemniku ma określony numer, który ją identyfikuje - taki właśnie numer umieszczamy na stronie <span class="inline">[]</span>. Warto zauważyć, że zawartość tablicy <b>zawsze zaczyna się od 0</b> i <i>nigdy nie</i>może <i>być ujemna</i><em>!</em></p>
    <h3 class="dropspot">       Tworzenie tablic</h3>
    <p class="dropspot">Pokazaliśmy już, jak sprawdzać tablicę w poszukiwaniu danych, ale jak utworzyć tablicę na początek? Najpierw trzeba ją <i>zainicjalizować</i>, zanim będziemy mogli jej użyć, inaczej <span data-keyref="GameMaker Name">GameMaker</span> wyśle nam błąd. Inicjalizacja tablicy oznacza po prostu, że nadajemy każdemu slotowi tablicy wartość początkową, przygotowując go do użycia w innym miejscu kodu projektu. Należy o tym pamiętać, ponieważ oznacza to, że przed użyciem tablic trzeba się nieco zastanowić, ale inicjalizacja tablicy za pomocą powtórzenia <span class="notranslate">loop</span> jest dość prosta:</p>
    <p class="code">var i = 9;<br /><br />
      repeat(10)<br />
      {<br />
          array[i] = 0;<br />
          i -= 1;<br />
      }</p>
    <p class="dropspot">Ten prosty kod zainicjalizuje tablicę z dziesięcioma szczelinami (od 0 do 9) tak, aby zawierała 0, tzn. każda szczelina w tablicy zawiera wartość 0. Zauważysz, że tablica została zainicjalizowana od <i>tyłu</i>, z ostatnią wartością zdefiniowaną jako pierwsza. Nie jest to absolutnie konieczne, ale jest to optymalny sposób, ponieważ zarezerwowane zostanie miejsce w pamięci o dokładnym rozmiarze tablicy, podczas gdy inicjalizacja tablicy od 0 w <em>górę</em> powoduje konieczność ponownego przydzielenia pamięci dla każdej dodanej wartości (tak więc dla tablicy dziesięciogniazdowej inicjalizacja w <span class="notranslate">loop</span> spowodowałaby dziesięciokrotną zmianę przydziału pamięci). Różnica w szybkości działania jest pomijalna w przypadku mniejszych tablic, ale większe tablice powinny być w ten sposób optymalizowane na tyle, na ile to możliwe.</p>
    <p class="note"><b>UWAGA</b>: Wyjątkiem od powyższej reguły jest eksport HTML5, w którym należy inicjalizować tablice w kolejności od 0 w górę.</p>
    <p class="dropspot">Można także użyć funkcji <span class="notranslate">GML</span> <a href="../GML_Reference/Variable_Functions/array_create.htm"><span class="inline">array_create()</span></a> do inicjalizacji tablicy o stałym rozmiarze, a nawet można tworzyć &quot;puste&quot; tablice, na przykład <em>bez</em> wartości:</p>
    <p class="code">my_array = [];</p>
    <p class="dropspot">Dzięki temu <span class="notranslate">GameMaker</span> dowie się, że zmienna &quot;<span class="inline">my_array</span>&quot; jest tablicą i można do niej <a href="../GML_Reference/Variable_Functions/array_push.htm">dodawać wartości</a> w dowolnym momencie w przyszłości. Jeśli jednak spróbujesz uzyskać dostęp do wartości w pustej tablicy, otrzymasz błąd.<br></p>
    <p class="dropspot">Jeśli wiesz już, które elementy chcesz umieścić w tablicy, możesz dodać wartości oddzielone przecinkami między nawiasami podczas deklarowania tablicy:</p>
    <p class="code">my_array = [&quot;Steve&quot;, 36, &quot;ST-3V3 - Steve Street&quot;];</p>
    <h3 class="dropspot">       Granice tablic</h3>
    <p class="dropspot">Należy zawsze zwracać uwagę na to, aby mieć dostęp tylko do prawidłowych pozycji w tablicy, ponieważ próba dostępu do wartości spoza tablicy również spowoduje błąd. Na przykład spowoduje to awarię projektu podczas jego uruchamiania:</p>
    <p class="code">my_array = array_create(5, 0);<br />
      var _val = my_array[6];</p>
    <p class="dropspot">Tablica została zainicjowana tylko na 5 pozycji, ale próbowaliśmy uzyskać pozycję 7 - ponieważ tablice są numerowane od 0, <span class="inline">array[6]</span> jest pozycją 7 - dlatego gra generuje błąd i zawiesza się.</p>
    <h3 class="dropspot">       Używanie tablic</h3>
    <p class="dropspot">Jak praktycznie używać tablicy? Dokładnie tak samo, jak w przypadku zwykłej zmiennej, jak pokazano w poniższych przykładach:</p>
    <p class="code">// Add two array values together<br />
      total = array[0] + array[5];<br />
      <br />
      // Check an array value<br />
      if array[9] == 10<br />
      {<br />
          // Do something<br />
      }<br />
      <br />
      // Draw an array value<br />
      draw_text(32, 32, array[3]);
    </p>
    <p class="dropspot">Ponieważ tablice są numerowane sekwencyjnie, oznacza to, że możesz <span class="notranslate">loop</span> przez nie przejść, aby wykonać dodatkowe czynności, tak jak to zrobiliśmy przy inicjalizacji:</p>
    <p class="code">var total = 0;<br />
      <br />
      for (var i = 0; i &lt; 10; ++i)<br />
      {<br />
          total += array[i];<br />
          draw_text(32, 32 + (i * 32), array[i]);<br />
      }<br />
      <br />
      draw_text(32, 32 + (i * 32), total);
    </p>
    <p class="dropspot">Powyższy kod zsumuje wszystkie wartości w naszej tablicy, narysuje każdą z nich, a następnie na końcu narysuje wartość całkowitą.</p>
    <h3 class="dropspot">       Usuwanie tablic</h3>
    <p class="dropspot">Ostatnią rzeczą, o której należy wspomnieć w odniesieniu do tablic, jest to, że można je usunąć, po prostu &quot;przypisując&quot; zmiennej, która je definiuje, pojedynczą wartość. Spowoduje to zwolnienie pamięci związanej ze wszystkimi pozycjami i wartościami tej tablicy. Na przykład:</p>
    <p class="code">// Create an array<br />for (var i = 9; i &gt; -1; --i)<br />
      {<br />
          a[i] = i;<br />
      }<br />
      <br />
      // Delete the array<br />
      a = -1;
    </p>
    <p class="dropspot">Jeśli tablica ma wiele wymiarów (patrz niżej), zostaną one również wyczyszczone. Zauważ, że gdy tworzysz tablice w instancjach, nie trzeba ich czyścić, gdy instancja zostanie usunięta z gry, ponieważ zostaną one automatycznie usunięte przez <a class="glossterm" data-glossterm="odśmiecacz (garbage collector)" href="#">garbage collector</a> w momencie Destroy lub <span class="notranslate">Room</span> End. Jeśli jednak w którejś z pozycji tablicy znajdują się odwołania do <em>dynamicznych</em> zasobów, takich jak systemy cząsteczek, <span class="notranslate">buffers</span> lub struktury danych, <em>będą</em> one musiały zostać zniszczone przed usunięciem tablicy, zniszczeniem instancji lub zakończeniem <span class="notranslate">room</span>.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#">Tablice wielowymiarowe</a></p>
  <div class="droptext" data-targetname="drop-down2">
    <p class="dropspot"><span style="text-align: justify;">Wiemy już, czym jest tablica jednowymiarowa, ale w <span data-keyref="GameMaker Name">GameMakerze</span> można mieć tablice wielowymiarowe, które są skonstruowane jako tablica wewnątrz tablicy wewnątrz tablicy... Na przykład poniżej przedstawiono tablicę <strong>2D</strong> (dwuwymiarową):</span></p>
    <p class="code">array[0][0] = 5;</p>
    <p class="dropspot">Jest to w zasadzie informacja dla <span class="notranslate">GameMaker</span>, że tablica składa się z różnych tablic 1D. Oto rozszerzony przykład:</p>
    <p class="code">array<strong>[0]</strong>[0] = 0;<br />
      array<strong>[0]</strong>[1] = 1;<br />
      array<strong>[0]</strong>[2] = 2;<br />
      <br />
      array<strong>[1]</strong>[0] = 3;<br />
      array<strong>[1]</strong>[1] = 4;<br />
      <strong></strong>array<strong>[1]</strong>[2] = 5;
    </p>
    <p class="dropspot">W powyższym kodzie adres <span class="inline">array[0]</span> zawiera inną tablicę, podobnie jak adres <span class="inline">array[1]</span>.</p>
    <p class="dropspot">Tablica wielowymiarowa wymaga inicjalizacji przed użyciem, tak samo jak pojedyncza tablica 1D, i może przechowywać liczby rzeczywiste, <span class="notranslate">strings</span> oraz wszelkie inne <a href="Data_Types.htm">typy danych</a>, tak jak każda inna zmienna, co czyni je idealnymi kandydatami do każdej gry, która musi przechowywać duże ilości danych w łatwo dostępny sposób (pamiętaj, że możesz <span class="notranslate">loop</span> łatwo przeglądać tablicę).</p>
    <p class="dropspot">W jednym wyrażeniu można również zainicjować tablicę wielowymiarową, zagnieżdżając w niej tablice jednowymiarowe:</p>
    <p class="code">two_dimensional_array = <br />
      [<br />
          [&quot;Apple&quot;, 10, 2],<br />
          [&quot;Orange&quot;, 5, 2],<br />
          [&quot;Mango&quot;, 15, 4],<br />
          // ...and so on.<br />
      ]</p>
    <p class="dropspot"> <span class="inline">[n]</span> Tablice wielowymiarowe nie ograniczają się <em>tylko </em>do dwóch wymiarów. W kodzie można dodać 3, 4 lub więcej wymiarów do tablicy, dodając kolejne argumenty, np:</p>
    <p class="code">array[0][0][0] = 1;     // A three dimensional array<br />
      array[0][0][0][0] = 1;  // A four dimensional array<br />
      // etc...</p>
    <p class="dropspot">Należy również zauważyć, że długość każdego wymiaru w tablicy może być różna, więc początkowy wymiar tablicy może mieć długość 3, ale drugi wpis wymiaru może mieć inną długość dla każdego gniazda w pierwszym wymiarze; na przykład:</p>
    <p class="code">array[2][2] = &quot;3&quot;;<br />
      array[2][1] = &quot;2&quot;;<br />
      array[2][0] = &quot;1&quot;;<br />
      <br />
      array[1][3] = &quot;four&quot;;<br />
      array[1][2] = &quot;three&quot;;<br />
      array[1][1] = &quot;two&quot;;<br />
      array[1][0] = &quot;one&quot;;<br />
      <br />
      array[0][1] = 2;<br />
      array[0][0] = 1;
    </p>
    <p class="dropspot">W powyższym kodzie na stronie <span class="inline">array[0]</span> znajdują się 2 gniazda, na stronie <span class="inline">array[1]</span> - 4 gniazda, a na stronie <span class="inline">array[2]</span> - 3 gniazda.</p>
    <h3 class="dropspot">       Przykład rozszerzony</h3>
    <p class="dropspot">Oto ostatni przykład zastosowania tego rozwiązania w rzeczywistej grze: Powiedzmy, że chcemy wywołać czterech różnych wrogów w czterech różnych punktach gry, w zależności od losowej wartości. Do tego celu możemy użyć tablicy o dwóch wymiarach, oszczędzając sobie pisania całego kodu.</p>
    <p class="dropspot">Najpierw powinniśmy zainicjować tablicę, której będziemy używać w zdarzeniu Create naszego &quot;kontrolera&quot; <span class="notranslate">object</span> (zwróć uwagę na komentarze przypominające, co robi każdy element tablicy):</p>
    <p class="code">enemy[3][2] = 448;       //y position<br />
      enemy[3][1] = 32;        //x position<br />
      enemy[3][0] = obj_Slime; //Object<br />
      enemy[2][2] = 448;<br />
      enemy[2][1] = 608;<br />
      enemy[2][0] = obj_Skeleton;<br />
      enemy[1][2] = 32;<br />
      enemy[1][1] = 608;<br />
      enemy[1][0] = obj_Knight;<br />
      enemy[0][2] = 32;<br />
      enemy[0][1] = 32;<br />
      enemy[0][0] = obj_Ogre;</p>
    <p class="dropspot">W naszej tablicy znajdują się teraz instancje <span class="notranslate">objects</span> do wywołania oraz odpowiadające im współrzędne x i y w obrębie <span class="notranslate">room</span>. Można to teraz wykorzystać w innym zdarzeniu kontrolera <span class="notranslate">object</span> (na przykład w alarmie lub zdarzeniu naciśnięcia klawisza):</p>
    <p class="code">//get a random number from 0 to 3, inclusive<br />
      var i = irandom(3);<br />
      <br />
      //Use the array to create the object<br />
      instance_create_layer(enemy[i][1], enemy[i][2], &quot;Enemy_Layer&quot;, enemy[i][0]);
    </p>
    <p class="dropspot">Ten krótki kod będzie teraz wywoływał losowego przeciwnika w grze <span class="notranslate">room</span> i używa o wiele mniej kodu niż struktura &quot;<span class="inline">if / then / else</span>&quot; lub nawet &quot;<span class="inline">switch</span>&quot;, a ponieważ tablica jest inicjalizowana w zdarzeniu tworzenia, o wiele łatwiej jest edytować i zmieniać dowolne wartości, ponieważ nie są one na <a class="glossterm" data-glossterm="twardo zakodowane" href="#">stałe zakodowane</a> w reszcie kodu projektu.</p>
  </div>
  <p> </p>
  <h2>Tablice jako argumenty funkcji</h2>
  <p>Można przekazywać tablice do <a href="Script_Functions.htm">funkcji skryptu</a> i <a href="Method_Variables.htm">zmiennych metod</a> jako argumenty, a następnie modyfikować te tablice w dowolnym miejscu wewnątrz funkcji. W ten sposób modyfikuje się również oryginalne tablice.</p>
  <p>Na przykład ta funkcja po prostu zmienia trzy pierwsze elementy przekazanej jej tablicy:</p>
  <p class="code">modify_array = function (array)<br />
    {<br />
        array[0] = 2;<br />
        array[1] = 4;<br />
        array[2] = 6;<br />
    }</p>
  <p>Można teraz utworzyć tablicę i przekazać ją do tej funkcji, która zmodyfikuje tablicę:</p>
  <p class="code">my_array = [100, 4, 214];<br />
    <br />
    modify_array(my_array);<br />
    <br />
    show_debug_message(my_array); // Prints [2, 4, 6];
  </p>
  <p>W poprzednich wersjach <span class="notranslate">GameMaker</span> nie było to możliwe, ponieważ modyfikacja tablicy wewnątrz funkcji powodowała utworzenie kopii. To <em>przestarzałe</em> zachowanie nadal można włączyć, jeśli jest to pożądane: przeczytaj sekcję &quot;<strong>Kopiowanie przy zapisie</strong>&quot; poniżej, aby uzyskać więcej informacji.</p>
  <h2 id="h">Kopiuj na Napisz</h2>
  <p> <a href="../../Settings/Game_Options.htm">Opcja</a> Kopiuj przy zapisie jest przestarzała i jest używana tylko wtedy, gdy w <a href="../../Settings/Game_Options.htm">opcjach ogólnych gry</a> włączona jest opcja &quot;<strong>Włącz zachowanie Kopiuj przy zapisie dla</strong> tablic&quot;. W tym rozdziale opisano zachowanie tablic, gdy ta opcja jest włączona.</p>
  <p>Jak opisano w poprzednim rozdziale, tablice można przekazywać do funkcji jako argumenty. W tym celu wystarczy podać zmienną tablicową (nie trzeba podawać poszczególnych pozycji ani nawiasów <span class="inline">[]</span> ), a cała tablica zostanie <b>przekazana</b> do funkcji <b>przez referencję</b>:</p>
  <p class="code">my_array = [1, 2, 4, 8, 16];<br />
    <br />
    do_something(my_array);
  </p>
  <p>Jednak gdy włączona jest opcja <strong>Kopiuj przy zapisie</strong>, zmiana dowolnej wartości tablicy wewnątrz funkcji powoduje utworzenie tymczasowej kopii z wprowadzonymi zmianami. Oryginalna tablica nie jest modyfikowana. Takie zachowanie nazywa się Kopiowanie przy zapisie.</p>
  <p>Aby faktycznie zmodyfikować oryginalną tablicę, która została przekazana do funkcji, należy albo zwrócić ją z powrotem, albo użyć argumentu dostępu <span class="inline">@</span>.</p>
  <p>Na przykład funkcja wywołana powyżej, <span class="inline2">do_something()</span>, może wykonać coś tak prostego, jak poniżej:</p>
  <p class="code">do_something = function(array)<br />
    {<br />
        array[1] = 200;<br />
    }</p>
  <p>Można by oczekiwać, że <span class="inline2">moja_tablica</span> będzie miała wartości <span class="inline2">1, 200, 4</span> itd., co w normalnych warunkach byłoby poprawne - ale gdy włączone jest <strong>kopiowanie przy zapisie</strong>, oryginalna tablica pozostaje nienaruszona.</p>
  <p>Aby obejść ten problem, można sprawić, że funkcja <strong>zwróci</strong> zmodyfikowaną kopię tablicy, a następnie zastosuje ją z powrotem do oryginalnej zmiennej:</p>
  <p class="code">my_array = [1, 2, 4, 8, 16];<br />
    <br />
    my_array = do_something(my_array);
  </p>
  <p>Sama funkcja zwróciłaby zmodyfikowaną tablicę:</p>
  <p class="code">do_something = function(array)<br />
    {<br />
        array[1] = 200;<br />
    <br />
        return array;<br />
    }
  </p>
  <p class="note"><span class="note">UWAGA</span><b> </b>Powyższy kod nie jest konieczny, jeśli nie zmieniamy żadnej z wartości tablicy, a jedynie odwołujemy się do nich. Odwołanie do tablicy nie spowoduje jej skopiowania i będzie szybsze w parsowaniu.</p>
  <p>Drugim rozwiązaniem jest użycie dostępnika <span class="inline">@</span> do bezpośredniej zmiany wartości tablicy, co pozwala zaoszczędzić obciążenie procesora związane z tworzeniem tymczasowej kopii. Oznacza to, że nie trzeba zwracać tablicy z funkcji i można ją bezpośrednio edytować:</p>
  <p class="code">do_something = function(array)<br />
    {<br />
        array[@ 1] = 200;<br />
    }</p>
  <p>Użycie tego dostępnika pozwala ominąć zachowanie Kopiuj przy zapisie i bezpośrednio zmodyfikować tablicę, do której się odwołujemy. Może to być użyte do selektywnego wyłączenia funkcji Kopiuj przy zapisie dla określonych instrukcji, przy jednoczesnym utrzymaniu tej opcji włączonej.</p>
  <p>Ponownie, wszystkie te czynności nie są konieczne, jeśli opcja <strong>Kopiuj przy zapisie</strong> jest <strong>wyłączona</strong> (co jest opcją domyślną i zalecaną).</p>
  <p>Więcej informacji na temat akcesorów i sposobu ich działania, wraz z przykładem dotyczącym tablic, można znaleźć na następującej stronie:</p>
  <ul class="colour">
    <li><a href="Accessors.htm">Akcesoria</a></li>
  </ul>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Powrót: <a href="GML_Overview.htm">Przegląd GML</a></div>
        <div style="float:right">Następny: <a data-xref="{title}" href="Structs.htm">Struktury i konstruktory</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Wszystkie prawa zastrzeżone.</span></h5>
  </div>
  <!-- KEYWORDS
Arrays
passing arrays to scripts
deleting arrays
-->
  <!-- TAGS
arrays
-->
</body>
</html>