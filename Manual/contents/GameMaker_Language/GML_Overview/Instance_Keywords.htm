<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Słowa kluczowe instancji</title>
    <meta name="generator" content="Adobe RoboHelp 2020" />
    <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
    <script src="../../assets/scripts/main_script.js"></script>
    <meta name="rh-authors" content="Mark Alexander" />
    <meta name="topic-comment" content="Page outlining the different instance &quot;keywords&quot;" />
    <meta name="rh-index-keywords" content="Instance Keywords,noone,self,other,all" />
    <meta name="search-keywords" content="self,all,noone,other,instance keywords" />
  </head>
  <body><!--<div class="body-scroll" style="top: 150px;">-->
    <h1>Słowa kluczowe instancji</h1>
    <p>Aby ułatwić sobie pewne rzeczy w programie <span data-keyref="GameMaker Name">GameMaker</span>, możesz użyć w swoim kodzie jednego z kilku <b>słów kluczowych instancji</b> (czy to <span class="notranslate">GML</span>, czy <span class="notranslate">GML</span> Visual). Te słowa kluczowe służą przede wszystkim do identyfikowania instancji - a w niektórych przypadkach także <span class="notranslate">structs</span> - w różnych sytuacjach, a każde z nich jest wyjaśnione w poniższym tekście.</p>
    <p>Zauważ, że wszystkie podane słowa kluczowe są wewnętrznie reprezentowane przez <strong>ujemne</strong> wartości całkowite, więc należy zachować ostrożność podczas przypisywania lub sprawdzania wartości zmiennych względem lub z tymi słowami kluczowymi, ponieważ możesz później uzyskać nieoczekiwane wyniki, gdy <span data-keyref="GameMaker Name">GameMaker</span> zinterpretuje wartość, której użyłeś, jako coś innego. Należy również pamiętać, że używanie w kodzie wartości całkowitych bezpośrednio zamiast słów kluczowych nie jest <b>zalecane</b> i może być przyczyną późniejszych problemów.</p>
    <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#"><span class="inline">self</span></a></p>
    <div class="droptext" data-targetname="drop-down">
      <table class=" cke_show_border">
        <tbody>
          <tr>
            <th>Słowo kluczowe</th>
            <th>Opis</th>
            <th>wartość</th>
          </tr>
          <tr>
            <td><span class="notranslate"><span class="inline">self</span></td>
            <td>Instancja/struktura, która wykonuje bieżący blok kodu.</td>
            <td><span class="notranslate">   -1</span></td>
          </tr>
        </tbody>
      </table>
      <p class="dropspot"><span class="inline">self</span> można użyć do zidentyfikowania bieżącej strony <span class="notranslate">struct</span> lub instancji, która jest objęta zakresem w bieżącym bloku kodu. Na przykład:</p>
      <p class="code">var val = 100;
        <br/>
        with (instance_create_layer(x, y, &quot;Instances&quot;, obj_Fire))
        <br/>
        {
        <br/>
        self.val = val;
        <br/>
        }</p>
      <p class="dropspot">W tym przykładzie widać, że mamy zmienną <i>lokalną</i> o nazwie <span class="inline">val</span> i chcemy, aby ustawiła ona zmienną <i>instancji</i> o tej samej nazwie w nowo utworzonej instancji <span class="notranslate">object</span>. Aby poprawnie zidentyfikować zmienną instancji i powiedzieć programowi <span data-keyref="GameMaker Name">GameMaker</span>, by ustawił ją w instancji wywołującej blok kodu, używamy słowa kluczowego <span class="inline">self</span>. W większości przypadków można też używać wbudowanej zmiennej instancji <span class="inline">id</span> zamiast <span class="inline">self</span>, ale <span class="inline">self</span> oferuje pewne korzyści. Po pierwsze, kompilator szybciej identyfikuje instancję (lub <span class="notranslate">struct</span>) za pomocą <span class="inline">self</span> niż <span class="inline">id</span>, ponieważ wartość <span class="inline">id</span> przechodzi przez tabelę wyszukiwania instancji, podczas gdy <span class="inline">self</span> nie. Po drugie, dla osób tworzących <span class="notranslate">extensions</span> bardzo przydatne jest zapewnienie poprawnego zakresu zmiennych, ponieważ może się zdarzyć, że projekt używający <span class="notranslate">extension</span> będzie miał zmienną o zakresie globalnym lub coś o takiej samej nazwie jak zmienna w <span class="notranslate">extension</span>.</p>
      <p class="note"><strong>UWAGA</strong>: Słowo kluczowe <span class="inline">self</span> <strong>nie </strong>jest skrótem do rzeczywistej wartości ID instancji lub <span class="notranslate">struct</span> i powinno być używane tylko w kontekście wyjaśnionym powyżej. Jeśli potrzebujesz <strong>wartości </strong>ID dla instancji, musisz użyć <span class="inline">self.id</span>, np:</p>
      <p class="code">var myID = id;
        <br/>
        with (all)
        <br/>
        {
        <br/>
        if self.id == myID
        <br/>
        {
        <br/>
        // do something
        <br/>
        }
        <br/>
        }</p>
      <p class="dropspot">Warto również zauważyć, że <span class="inline">self</span> może być również używany wewnątrz <a href="Structs.htm">struktur</a> - w bardzo szczególnych okolicznościach - do odwoływania się do zmiennych członkowskich dla <span class="notranslate">struct</span>.</p>
      <p class="dropspot"> </p>
    </div>
    <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#"><span class="inline">other</span></a></p>
    <div class="droptext" data-targetname="drop-down1">
      <table class=" cke_show_border">
        <tbody>
          <tr>
            <th>Słowo kluczowe</th>
            <th>Opis</th>
            <th>wartość</th>
          </tr>
          <tr>
            <td><span class="notranslate"><span class="inline">other</span></td>
            <td>Druga instancja uczestnicząca w zdarzeniu kolizyjnym, w funkcji <span class="inline">with</span> lub w funkcji.</td>
            <td><span class="notranslate">   -2</span></td>
          </tr>
        </tbody>
      </table>
      <p class="dropspot">Specjalnego słowa kluczowego <span class="inline">other</span> można użyć na wiele sposobów, aby odwołać się do konkretnej instancji (a w niektórych przypadkach do <span class="notranslate">struct</span>): można go użyć w instrukcji <span class="inline">with</span> (wyjaśniono <a href="Language_Features/with.htm">tutaj</a>), w <a href="../../The_Asset_Editors/Object_Properties/Object_Events.htm">zdarzeniu kolizji</a> lub w funkcji. W tym rozdziale zostaną wyjaśnione dwa ostatnie przypadki użycia.</p>
      <p class="dropspot">Należy pamiętać, że w zdarzeniach innych niż zderzenie, poza wywołaniami funkcji i blokami <span class="inline">with()</span>, <span class="inline">other</span> zwraca po prostu adres <span class="notranslate">struct</span> dla bieżącej instancji.</p>
      <h2 class="dropspot">Zdarzenie kolizyjne</h2>
      <p class="dropspot">Zdarzenie kolizji może wystąpić tylko między <strong>dwiema </strong>instancjami. <i>Możesz</i> mieć wiele kolizji między wieloma instancjami, ale wszystkie one są rozwiązywane przez <span data-keyref="GameMaker Name">GameMaker</span> na zasadzie 1 na 1, z instancją &quot;własną&quot;, która ma zdarzenie kolizji i &quot;drugą&quot; instancją, która się z nią zderza.</p>
      <p class="dropspot">Wyobraź sobie, że masz instancję gracza, wiele instancji przeciwnika i wiele instancji pocisków, które przeciwnik może wystrzelić w twoją stronę. Możesz przypisać każdemu wrogowi jedną instancję pocisku, ale z inną zmienną obrażeń, losowo przypisaną do niego podczas tworzenia:</p>
      <p class="code">var bullet;
        <br/>
        bullet = instance_create_layer(x, y, &quot;Bullets&quot;, obj_Bullet);
        <br/>
        bullet.damage = 5 + irandom(5);
        <br/>
        bullet.speed = 8;
        <br/>
        bullet.direction = point_direction(x, y, obj_Player.x, obj_Player.y);</p>
      <p class="dropspot">Możesz zobaczyć, jak ustawiamy jego zmienne, używając notacji kropkowej, tak jak to opisano w rozdziale <a href="Addressing_Variables_In_Other_Instances.htm">Adresowanie zmiennych w innych instancjach</a>. Dzięki temu każda instancja pocisku będzie miała inną wartość obrażeń, ale w jaki sposób gracz wykryje obrażenia, które musi przyjąć, gdy zostanie trafiony pociskiem?</p>
      <p class="dropspot">W tym celu gracz będzie musiał utworzyć zdarzenie kolizji z <span class="inline">obj_Bullet</span>, a w tym zdarzeniu użyć <span class="inline">other</span> do odczytania zmiennych z instancji zderzającego się pocisku:</p>
      <p class="code">hp -= other.damage;
        <br/>
        if hp &lt;= 0 instance_destroy();</p>
      <p class="dropspot">Powyższy kod odejmie kwotę zapisaną w zmiennej &quot;damage&quot; <i>drugiej</i> instancji od zmiennej &quot;hp&quot; gracza, a następnie sprawdzi, czy &quot;hp&quot; jest mniejsze lub równe 0. Jeśli tak, to zniszczy instancję gracza. Zwróć uwagę, że druga instancja musi mieć sprawdzaną zmienną, w przeciwnym razie zostanie wyświetlony błąd.</p>
      <p class="note"><strong>UWAGA</strong>: Zdarzenie Kolizja jest jedynym zdarzeniem, które ma specjalne znaczenie dla słowa kluczowego <span class="inline">other</span>. We wszystkich innych zdarzeniach oraz na stronie <span class="notranslate">scripts</span> zachowanie słowa <span class="inline">other</span> będzie określone przez kontekst, w którym jest ono używane (np. blok <span class="inline">with() </span>, funkcja, deklaracja <span class="notranslate">struct</span> itd.).</p>
      <p class="dropspot">Zmiennym można przypisywać wartości, a nawet tworzyć nowe, używając adresu <span class="inline">other</span> w zdarzeniu kolizji, jak poniżej:</p>
      <p class="code">// add ten to the other instance &quot;mana&quot; variable
        <br/>
        other.mana += 10;
        <br/>
        // set the other instance variable &quot;hit&quot; to true, creating the variable if it doesn&#39;t already exist
        <br/>
        other.hit = true;</p>
      <h2 class="dropspot">Deklaracja struktury</h2>
      <p class="dropspot">Gdy jest użyta wewnątrz deklaracji <span class="notranslate">struct</span>, <span class="inline">other</span> odnosi się do instancji inicjalizującej strukturę:</p>
      <p class="code">var _struct =
        <br/>
        {
        <br/>
        parent_instance : other
        <br/>
        }
        <br/>
        <br/>
        show_debug_message(_struct.parent_instance == self);
        <br/>
        // This prints &#39;1&#39; (true) meaning that both sides refer to the same instance </p>
      <p class="dropspot">Nie musisz jednak używać <span class="inline">other</span> do odczytywania zmiennych z instancji, ponieważ wszystkie zmienne, do których odwołujesz się bezpośrednio, zostaną odczytane z zakresu tej instancji, jak opisano <a href="Structs.htm#inst_in_struct">w tej części</a> podręcznika. Musiałbyś tego użyć tylko wtedy, gdybyś chciał przechowywać odwołanie do zmiennych tej instancji <span class="notranslate">struct</span>.</p>
      <h2 class="dropspot">Metoda instancji</h2>
      <p class="dropspot">Użycie <span class="inline">other</span> wewnątrz metody innej instancji <a href="Method_Variables.htm"><span class="notranslate">method</span></a> odnosi się do instancji, która wywołała tę metodę.</p>
      <p class="dropspot">Na przykład, załóżmy, że <span class="inline">Object2</span> ma metodę, która odwołuje się do <span class="inline">self</span> i <span class="inline">other</span>. Metoda ta jest następnie wywoływana w <span class="inline">Object1</span>. Ponieważ metoda ta została utworzona w <span class="inline">Object2</span>, jest z nią <strong>związana</strong> i zawsze będzie używać instancji <span class="inline">Object2</span> jako &quot;self&quot;, niezależnie od tego, która instancja ją wywoła. W takim przypadku instancją wywołującą staje się <span class="inline">other</span>.</p>
      <p class="code">// In Object2
        <br/>
        my_method = function()
        <br/>
        {
        <br/>
        show_debug_message(object_get_name(self.object_index));
        <br/>
        show_debug_message(object_get_name(other.object_index));
        <br/>
        }
        <br/>
        <br/>
        // In Object1
        <br/>
        Object2.my_method(); </p>
      <p class="dropspot">Spowoduje to, że instancja najpierw wypisze swoją własną nazwę <span class="notranslate">object</span> (&quot;Object2&quot;), a następnie nazwę <span class="notranslate">object</span> instancji wywołującej (&quot;Object1&quot;).</p>
      <p class="dropspot">To samo dotyczy metody, która jest związana z adresem <span class="notranslate">struct</span>.</p>
      <h2 class="dropspot">Funkcja konstruktora</h2>
      <p class="dropspot">Gdy zostanie użyty wewnątrz funkcji konstruktora, <span class="inline">other</span> będzie odwoływał się do instancji wywołującej tę funkcję, jednak nie jest to zalecane do ogólnego użytku, ponieważ wszelkie zewnętrzne dane, z których konstruktor musi korzystać, powinny być przekazywane jako argumenty.</p>
      <p class="dropspot"> </p>
    </div>
    <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#"><span class="inline">all</span></a></p>
    <div class="droptext" data-targetname="drop-down2">
      <table class=" cke_show_border">
        <tbody>
          <tr>
            <th>Słowo kluczowe</th>
            <th>Opis</th>
            <th>wartość</th>
          </tr>
          <tr>
            <td><span class="notranslate"><span class="inline">all</span></td>
            <td>Wszystkie instancje aktualnie aktywne w serwisie <span class="notranslate">room</span>.</td>
            <td><span class="notranslate">   -3</span></td>
          </tr>
        </tbody>
      </table>
      <p> </p>
      <p class="dropspot">Tego słowa kluczowego używa się, aby powiedzieć programowi <span data-keyref="GameMaker Name">GameMaker</span>, że funkcja ma być zastosowana lub sprawdzona we wszystkich aktywnych instancjach w <span class="notranslate">room</span> (instancje wyłączone nie będą sprawdzane ani udostępniane). <b>Nie możesz</b> użyć <span class="inline">all</span>, by uzyskać dostęp do zmiennych w innych instancjach lub ustawić je za pomocą metody punktowej (zobacz <a href="Addressing_Variables_In_Other_Instances.htm">tutaj</a>), ale <strong>możesz </strong>go użyć przy wywołaniu <a href="Language_Features/with.htm"><span class="inline">with()</span></a>na przykład:</p>
      <p class="code">with (all)
        <br/>
        {
        <br/>
        speed = 0;
        <br/>
        }</p>
      <p class="dropspot">Powyższy kod ustawi prędkość wszystkich instancji w <span class="notranslate">room</span> na 0. Można także użyć <span class="inline">all</span> w funkcjach, aby na przykład skierować lub sprawdzić wszystkie instancje w <span class="notranslate">room</span>:</p>
      <p class="code">// Check a point for any active instance in the room
        <br/>
        inst = instance_position(mouse_x, mouse_y, all);
        <br/>
        <br/>
        // Check all instances for a collision along a line
        <br/>
        if collision_line(x, y, mouse_x, mouse_y, all, false, true) {}
        <br/>
        <br/>
        // Add all instances in the room into a motion planning grid
        <br/>
        mp_grid_add_instances(grid, all, false); </p>
      <p class="dropspot"><span class="inline">all</span> jest bardzo użytecznym słowem kluczowym i może być używane w wielu sytuacjach w kodzie i działaniach, często zmniejszając ilość kodu, który trzeba napisać, aby osiągnąć pożądany efekt.</p>
      <p class="dropspot"> </p>
    </div>
    <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down3" href="#"><span class="inline">noone</span></a></p>
    <div class="droptext" data-targetname="drop-down3">
      <table class=" cke_show_border">
        <tbody>
          <tr>
            <th>Słowo kluczowe</th>
            <th>Opis</th>
            <th>wartość</th>
          </tr>
          <tr>
            <td><span class="notranslate"><span class="inline">noone</span></td>
            <td>Nie ma żadnego przypadku.</td>
            <td><span class="notranslate">   -4</span></td>
          </tr>
        </tbody>
      </table>
      <p class="dropspot">Może się to wydawać dziwne, ale wiele razy podczas programowania gier pojawia się potrzeba sprawdzenia, czy w danej lokacji, w danej kolizji itp. nie ma żadnych instancji. W takich przypadkach użyjesz tego słowa kluczowego, aby sprawdzić, czy nic nie ma, na przykład tak:</p>
      <p class="code">if instance_nearest(x, y, obj_enemy) != noone
        <br/>
        {
        <br/>
        //do something as there is an enemy instance near
        <br/>
        }</p>
      <p class="dropspot">W tym przykładzie funkcja <span class="inline">instance_nearest()</span> zwróci albo <span class="inline">noone</span>, albo unikatowy identyfikator najbliższej znalezionej instancji. Zasadniczo za każdym razem, gdy chcesz sprawdzić, czy istnieje jakaś instancja, możesz oczekiwać, że zwrócona zostanie albo <span class="inline">noone</span>, albo unikalny identyfikator instancji.</p>
      <p class="dropspot"> </p>
    </div>
    <p> </p>
    <p> </p>
    <p> </p>
    <div class="footer">
      <div class="buttons">
        <div class="clear">
          <div style="float:left">Powrót: <a href="GML_Overview.htm">Przegląd GML</a></div>
          <div style="float:right">Następny: <a data-xref="{title}" href="Evaluation_Order.htm">Kolejność oceniania</a></div>
        </div>
      </div>
      <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Wszystkie prawa zastrzeżone.</span></h5>
    </div>
    <!-- KEYWORDS
Instance Keywords
self
all
noone
other
--><!-- TAGS
instance_keywords
--></body>
</html>