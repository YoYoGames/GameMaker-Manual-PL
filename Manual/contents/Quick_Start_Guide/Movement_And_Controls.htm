<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Ruchy i kontrole</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <script src="../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Some basic code and GML Visualto show people how to move things around within a game." />
  <meta name="rh-index-keywords" content="Quick Start - Movement And Controls" />
  <meta name="search-keywords" content="movement,controls" />
  <meta name="robots" content="NOODP" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Ruchy i kontrole</h1>
  <p>W <a href="Drawing.htm">poprzedniej</a> części podręcznika Szybki start podano kilka przykładów rysowania elementów na ekranie, ale samo rysowanie nie jest dobre, jeśli nie można się nimi poruszać... Dlatego w tej części podamy kilka przykładów poruszania się po stronie <span class="notranslate">objects</span> oraz kilka podstawowych schematów sterowania w różnych typach gier. Wszystkie przykłady są podane przy użyciu <span class="notranslate">GML</span> Visual oraz <span class="notranslate">GML</span> Code, więc możesz użyć tego, z czym czujesz się bardziej komfortowo. Zwróć uwagę, że nie będziemy tu zbyt szczegółowo wyjaśniać poszczególnych zagadnień, ponieważ chcemy, abyś jak najszybciej zaczął tworzyć gry. Zachęcamy więc do zapoznania się z linkami na bieżąco oraz do korzystania z funkcji &quot;szukaj&quot; w podręczniku w celu znalezienia dodatkowych informacji na temat wszystkiego, czego nie jesteś pewien.</p>
  <p>Zanim przejdziesz dalej, warto utworzyć nowy projekt ( <span class="notranslate">GML</span> lub <span class="notranslate">GML</span> Visual) na <a href="../Introduction/The_Start_Page.htm">stronie startowej</a> i dodać (lub utworzyć) kilka <span class="notranslate">sprites</span> oraz <span class="notranslate">object</span> lub dwa - ponieważ będziemy podawać kod, który można przetestować przy ich użyciu - oraz upewnić się, że w projekcie jest <span class="notranslate">room</span>, w którym można umieszczać instancje. Nie przejmuj się zbytnio wyglądem strony <span class="notranslate">sprites</span> - wystarczy zwykły biały kwadrat, a gdy wszystko będzie gotowe, możesz zacząć pracować nad poniższymi przykładami.</p>
  <p> </p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down" href="#">Przesuń w kierunku myszy</a></p>
  <div class="droptext" data-targetname="drop_down">
    <p class="dropspot">Jednym z najprostszych sposobów poruszania się i interakcji <span class="notranslate">object</span> z graczem jest użycie myszy. W tym przykładzie pokażemy, jak za pomocą podstawowego kodu sprawić, by <span class="notranslate">object</span> poruszał się w kierunku miejsca, w którym użytkownik kliknął lewy przycisk myszy <img>.</p>
    <p class="dropspot">Na początek otwórz stronę <span class="notranslate">object</span>, przypisz do niej adres <span class="notranslate">sprite</span>, a następnie nadaj jej <strong>zdarzenie Globalny lewy przycisk myszy w dół</strong>:</p>
    <p class="dropspot"><img alt="LMB Icon" class="icon" src="../assets/Images/Icons/Icon_LMB.png" /></p>
    <p class="dropspot">Używamy <strong>globalnych </strong>zdarzeń myszy, ponieważ wykrywają one kliknięcie w dowolnym miejscu na stronie <span class="notranslate">room</span>, podczas gdy zwykłe zdarzenia myszy wykrywają kliknięcie tylko wtedy, gdy mysz kliknie w <a class="glossterm" data-glossterm="ramka ograniczająca" href="#">polu ograniczającym</a> instancji. W tym zdarzeniu chcemy dodać następujące akcje lub kod:</p>
    <p class="dropspot"><img alt="Adding The Mouse Left Button Down Event" class="center" src="../assets/Images/QS_Guide/QS_Add_GlobalLMBDownEvent.png" /></p>
    <p class="code">move_towards_point(mouse_x, mouse_y, 2);</p>
    <p class="dropspot">W tym przypadku chodzi o to, by instancja poruszała się w kierunku pozycji na ekranie, w tym przypadku pozycji &quot;<span class="inline">mouse_x</span>&quot; i &quot;<span class="inline">mouse_y</span>&quot; (&quot;<span class="inline">mouse_x</span>&quot; i &quot;<span class="inline">mouse_y</span>&quot; to <a class="glossterm" data-glossterm="zmienna" href="#">zmienne</a> <strong>wbudowane </strong>, które zawsze przechowują aktualną pozycję kursora myszy). Program <span class="notranslate">GML</span> Visual robi to, ustawiając &quot;<span class="inline">direction</span>&quot; i &quot; <span class="inline">speed</span>&quot; <a href="../GameMaker_Language/GML_Reference/Asset_Management/Instances/Instance_Variables/Instance_Variables.htm"><strong>Zmienne instancji</strong></a>, natomiast <span class="notranslate">GML</span> robi to za pomocą funkcji <a href="../GameMaker_Language/GML_Reference/Movement_And_Collisions/Movement/move_towards_point.htm"><span class="inline">move_towards_point()</span></a> (ustawia ona również zmienne <span class="inline">speed </span>i <span class="inline">direction </span>, tylko w jednej, łatwej w użyciu funkcji).</p>
    <p class="dropspot">Umieść instancję tej strony <span class="notranslate">object</span> na stronie <span class="notranslate">room</span>, a następnie naciśnij przycisk Odtwórz <img>, po czym kliknij <img> wokół strony <span class="notranslate">room</span>, aby instancja poruszała się w kierunku myszy:</p>
    <p class="dropspot"><img>Świetnie! Instancja strony <span class="notranslate">object</span> przesuwa się teraz w kierunku miejsca kliknięcia, a jeśli przytrzymasz przycisk, instancja będzie podążać za kursorem myszy. Jest jednak pewien problem... Po jednokrotnym kliknięciu i zwolnieniu przycisku instancja nadal będzie się poruszać i w końcu opuści stronę <span class="notranslate">room</span>! Jest kilka sposobów, by to naprawić, a to, który z nich wybierzesz, zależy od tego, co chcesz zrobić, ale najłatwiejszym rozwiązaniem jest dodanie zdarzenia <strong>globalnego zwolnienia przycisku myszy</strong>, więc dodaj je teraz do <span class="notranslate">object</span> i wpisz następujący kod:</p>
    <p class="dropspot"><img alt="GML VisualTo Move Instance Towards Mouse" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_1_1.png" /></p>
    <p class="code">speed = 0;</p>
    <p class="dropspot">Dzięki temu instancja będzie podążać za kursorem myszy tylko tak długo, jak długo będzie przytrzymywany przycisk myszy, a po jego zwolnieniu przestanie się poruszać. Naciśnij przycisk Play <img> i przetestuj działanie.</p>
    <p class="dropspot">Zanim opuścimy ten przykład, musimy jeszcze rozwiązać jeden problem... Jeśli klikniesz i <em>przytrzymasz </em>przycisk myszy, ale nie przesuniesz kursora, to instancja przesunie się w kierunku kursora, a następnie będzie wokół niego &quot;wibrować&quot;. Dzieje się tak dlatego, że instancja porusza się szybciej niż o 1 piksel na raz, a więc &quot;przeskakuje&quot; pozycję i próbuje się cofnąć, a potem znowu przeskakuje, itd... (ustaw prędkość ruchu na 5 lub coś podobnego, aby zobaczyć problem, jeśli nie jest on od razu oczywisty).</p>
    <p class="dropspot"><img>Aby rozwiązać ten problem, należy dodać <strong>zdarzenie Step</strong> do strony <span class="notranslate">object</span> za pomocą poniższego kodu:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">var _dist = point_distance(x, y, mouse_x, mouse_y);<br />
      <br />
      if _dist &lt;= speed<br />
      {<br />
          speed = 0;<br />
      }
    </p>
    <p class="dropspot">W tym przypadku po prostu sprawdzamy odległość instancji od pozycji myszy i jeśli jest ona taka sama lub mniejsza niż bieżąca prędkość, ustawiamy prędkość na 0. Dzięki temu instancja zatrzymuje się, gdy jest wystarczająco blisko pozycji myszy, a my nie mamy tego nieprzyjemnego problemu z &quot;drganiem&quot;.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down1" href="#">Ruch 4 i 8 kierunkowy za pomocą klawiatury</a></p>
  <div class="droptext" data-targetname="drop_down1">
    <p class="dropspot"><a href="What_Is_Programming_.htm">Na początku tego podręcznika</a> pokazaliśmy działanie i kod, które pozwalają przesunąć instancję w prawo o dwa piksele w każdym kroku gry:</p>
    <p class="dropspot"><img alt="LMB Icon" class="icon" src="../assets/Images/Icons/Icon_LMB.png" /></p>
    <p class="code">x = x + 2;</p>
    <p class="dropspot">Ten rodzaj ruchu nazywany jest ruchem <strong>pozycyjnym </strong>, ponieważ w istocie podnosimy instancję i umieszczamy ją ponownie w nowej pozycji za każdym razem, gdy uruchamiany jest kod. W tym przykładzie pokażemy, jak używać tego typu ruchu do poruszania instancją w czterech kierunkach: w górę, w dół, w lewo i w prawo.</p>
    <p class="dropspot">Na początek otwórz stronę <span class="notranslate">object</span> i przypisz jej adres <span class="notranslate">sprite</span>. W tym momencie moglibyśmy dodać różne <strong>zdarzenia klawiat</strong> ury, a w każdym z nich kazać instancji poruszać się w wybranym kierunku, jednak chcemy, aby gracz mógł poruszać się tylko w jednym kierunku na raz, a zrobienie tego tylko za pomocą zdarzeń klawiatury jest nieco bardziej skomplikowane niż zrobienie tego za pomocą kodu. Zamiast tego użyjemy <strong>zdarzenia Step</strong> - które powinieneś teraz dodać do strony <span class="notranslate">object</span> - z następującymi akcjami lub kodem, aby użyć klawiszy strzałek do poruszania się:</p>
    <p class="dropspot"><img alt="Animation Of Instance Moving Towards Mouse" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_1_1.gif" /></p>
    <p class="code">if keyboard_check(vk_left)<br />
      {<br />
          x = x - 2;<br />
      }<br />
      else if keyboard_check(vk_right)<br />
      {<br />
          x = x + 2;<br />
      }<br />
      else if keyboard_check(vk_up)<br />
      {<br />
          y = y - 2;<br />
      }<br />
      else if keyboard_check(vk_down)<br />
      {<br />
          y = y + 2;<br />
      }</p>
    <p class="dropspot">Używamy struktury &quot; <span class="inline">if... else if... else if...</span>&quot;, aby zapewnić, że instancja będzie poruszać się tylko w jednym kierunku na raz, a więc instancja powinna być w stanie poruszać się tylko w górę, w dół, w lewo lub w prawo, ale nie po przekątnej. Umieść instancję <span class="notranslate">object</span> na stronie <span class="notranslate">room</span> i naciśnij przycisk <strong>Odtwórz </strong> <img>, aby ją przetestować! Jeśli wszystko przebiegło poprawnie, powinieneś otrzymać coś takiego:</p>
    <p class="dropspot"><img alt="GML VisualTo Set The Instance Speed" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_1_2.png" /></p>
    <p class="dropspot">Kod ten można łatwo zmodyfikować, aby przekształcić ruch 4-kierunkowy w ruch 8-kierunkowy. Wystarczy usunąć polecenia &quot; <span class="inline">else</span>&quot; z bloków kodu, aby wszystko wyglądało tak, jak poniżej:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">if keyboard_check(vk_left)<br />
      {<br />
          x = x - 2;<br />
      }<br />
      if keyboard_check(vk_right)<br />
      {<br />
          x = x + 2;<br />
      }<br />
      if keyboard_check(vk_up)<br />
      {<br />
          y = y - 2;<br />
      }<br />
      if keyboard_check(vk_down)<br />
      {<br />
          y = y + 2;<br />
      }</p>
    <p class="dropspot">Teraz po naciśnięciu przycisku <strong>odtwarzania </strong> <img> będzie to wyglądało następująco:</p>
    <p class="dropspot"><img alt="Animation Showing Instance Vibrating" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_1_2.gif" /></p>
    <p class="dropspot">Ostatnia rzecz, na którą warto zwrócić uwagę użytkownikom kodującym za pomocą <span class="notranslate">GML</span>... Podczas korzystania z <span class="notranslate">GML</span> Visual można wybrać klawisz klawiatury, który ma być użyty, z listy rozwijanej, ale w przypadku <span class="notranslate">GML</span> nie jest to takie proste. Istnieje wiele stałych klawiaturowych, których można użyć - na przykład <a href="../GameMaker_Language/GML_Reference/Game_Input/Keyboard_Input/Keyboard_Input.htm">stałe</a> klawiszy strzałek pokazane w powyższym kodzie - ale <em>nie </em>ma stałych dla klawiszy alfanumerycznych. Są one obsługiwane w nieco inny sposób i wymagają użycia funkcji <a href="../GameMaker_Language/GML_Reference/Strings/ord.htm"><span class="inline">ord()</span></a>. Poniższy kod pokazuje, jak to działa przy użyciu klawisza WASD zamiast klawiszy strzałek:</p>
    <p class="code">if keyboard_check(ord(&quot;A&quot;))<br />
      {<br />
          x = x - 2;<br />
      }<br />
      if keyboard_check(ord(&quot;D&quot;))<br />
      {<br />
          x = x + 2;<br />
      }<br />
      if keyboard_check(ord(&quot;W&quot;))<br />
      {<br />
          y = y - 2;<br />
      }<br />
      if keyboard_check(ord(&quot;S&quot;))<br />
      {<br />
          y = y + 2;<br />
      }</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down2" href="#">Ruch gamepada</a></p>
  <div class="droptext" data-targetname="drop_down2">
    <p class="dropspot">Omówiliśmy już ruchy myszy i klawiatury, więc nadszedł czas, aby omówić ruchy <strong>gamepada </strong>. Nie będziemy się zajmować d-padem, ponieważ działa on tak samo jak klawiatura (wystarczy zmienić funkcje klawiatury w powyższym przykładzie na <a href="../GameMaker_Language/GML_Reference/Game_Input/GamePad_Input/gamepad_button_check.htm"><span class="inline">gamepad_button_check()</span></a> lub <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Gamepad/If_Gamepad_Button_Down.htm">If Gamepad button Down</a>), więc w tym przykładzie zajmiemy się używaniem drążka analogowego do poruszania się.</p>
    <p class="dropspot">Na początek musimy wykryć, jaki gamepad jest używany. Gamepady mają przypisane wartości ID od 0 do 11, więc użyjemy polecenia &quot; <span class="inline">for</span>&quot; <span class="notranslate">loop</span>, aby wykryć ID wszystkich podłączonych gamepadów i zapisać tę wartość ID w zmiennej do wykorzystania w przyszłości. Ponieważ chcemy wykryć tylko pierwszy podłączony gamepad, a nie wszystkie, po wykryciu gamepada użyjemy polecenia &quot; <span class="inline">break</span>&quot;, aby &quot;przerwać&quot; działanie <span class="notranslate">loop</span> (na przykład, jeśli pierwszy podłączony gamepad ma ID 4, to <span class="notranslate">loop</span> uruchomi się tylko 5 razy, sprawdzając wartości ID 0 - 4, a następnie wyłączy się z <span class="notranslate">loop</span> po napotkaniu gamepada). Utwórz więc (lub otwórz) stronę <span class="notranslate">object</span>, przypisz jej adres <span class="notranslate">sprite</span>, a następnie dodaj <strong>zdarzenie Create Event</strong> o następującej treści:</p>
    <p class="dropspot"><img alt="GML VisualActions For The Step Event" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_1_3.png" /></p>
    <p class="code">gamepad_id = -1;<br />
      <br />
      for (var i = 0; i &lt; 12; i += 1;)<br />
      {<br />
          if gamepad_is_connected(i)<br />
          {<br />
              gamepad_id = i;<br />
              gamepad_set_axis_deadzone(gamepad_id, 0.2);<br />
      <br />
              break;<br />
          }<br />
      }
    </p>
    <p class="dropspot">Zauważ, że w powyższym kodzie ustawiliśmy wartość <strong> <a class="glossterm" data-glossterm="deadzone" href="#">deadzone</a> </strong>dla gamepada. Dzieje się tak dlatego, że drążki analogowe w gamepadach różnych marek mają różną wrażliwość, a czasami mogą być tak wrażliwe, że jeśli nie ustawisz strefy martwej, mogą powodować niepożądane ruchy w grach. Dlatego ustawiamy strefę martwą na wartość taką jak 0,2, aby <span data-keyref="GameMaker Name">GameMaker</span> ignorował wszystkie wartości drążków poniżej tej wartości <a class="glossterm" data-glossterm="absolutny" href="#">bezwzględnej</a>.</p>
    <p class="dropspot">Aby dodać rzeczywisty ruch, potrzebujemy <strong>zdarzenia Step Event</strong>, więc dodaj je teraz i nadaj mu następującą nazwę: <span class="notranslate">GML</span> Visual lub GML:</p>
    <p class="dropspot"><img alt="GML VisualExample" class="center" src="../assets/Images/QS_Guide/QS_DnD_Example.png" /></p>
    <p class="code">if gamepad_id &gt; -1<br />
      {<br />
          var _h = gamepad_axis_value(gamepad_id, gp_axislh);<br />
          var _v = gamepad_axis_value(gamepad_id, gp_axislv);<br />
          x += _h * 4;<br />
          y += _v * 4;<br />
      }</p>
    <p class="dropspot">W tym przypadku sprawdzamy, czy <em>lewy </em>drążek porusza się w poziomie lub w pionie. Funkcje osi zwracają wartości z przedziału od -1 do 1, więc dla osi poziomej -1 oznacza lewo, 0 - brak ruchu, a 1 - prawo, natomiast dla osi pionowej -1 oznacza górę, 0 - brak ruchu, a 1 - dół. Zauważ też, że wartości zawierają się w <em>przedziale od </em>-1 do 1, więc na przykład oś pozioma może zwrócić wartość 0,5, co oznacza, że drążek jest w połowie drogi między położeniem spoczynkowym a pełnym wychyleniem w prawo. Z tego powodu mnożymy tę wartość przez 4 (możesz ją pomnożyć przez dowolną wartość, zależnie od prędkości, z jaką chcesz, by instancja się poruszała) - oznacza to, że prędkość instancji będzie się zmieniać w zależności od tego, jak duży ruch został wykonany na osi drążka.</p>
    <p class="dropspot">Umieść instancję tej strony <span class="notranslate">object</span> w witrynie <span class="notranslate">room</span> i naciśnij przycisk <strong>Play </strong>(Graj). <strong> <img></strong>a następnie poruszaj się, używając lewego drążka podłączonego gamepada. Powinieneś zobaczyć coś takiego:</p>
    <p class="dropspot"><img alt="GML VisualStep Event Movement Actions" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_2_1.png" /></p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down3" href="#">Zaawansowany ruch 8-drożny</a></p>
  <div class="droptext" data-targetname="drop_down3">
    <p class="dropspot">W tym ostatnim przykładzie ponownie przyjrzymy się naszemu kodowi ruchu 8-kierunkowego i zajmiemy się problemem, który w nim występuje: ruch po przekątnej jest szybszy niż ruch w górę/dół/lewo/prawo. Dzieje się tak po prostu dlatego, że podczas ruchu po przekątnej poruszasz się wzdłuż przeciwprostokątnej trójkąta prostokątnego utworzonego przez wartości ruchu x/y:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="dropspot">Aby lepiej zrozumieć, co się dzieje, usuńmy cały tekst oraz stronę <span class="notranslate">sprites</span> i po prostu pokażmy tę samą linię ruchu obróconą o 45°, tak aby była pozioma:</p>
    <p class="dropspot"><img alt="Animation Showing 4-Way Keyboard Movement" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_2_1.gif" /></p>
    <p class="dropspot">Jak widać, różnica jest dość oczywista, a jeśli instancja porusza się o więcej niż 1 lub 2 piksele na krok, to można zauważyć, że ruch po przekątnej jest <em>znacznie </em>szybszy! Jak więc to ograniczyć? Można to zrobić na wiele sposobów, ale my skoncentrujemy się na jednym z nich, ponieważ wprowadza on kilka funkcji i pojęć, które przydadzą się w późniejszych grach.</p>
    <p class="dropspot">Aby sobie z tym poradzić, będziemy musieli przechowywać w <a class="glossterm" data-glossterm="zmienna" href="#">zmiennych</a>wartości wejściowe z naciśniętych niezależnie klawiszy, a następnie sprawdzać je i poruszać się zgodnie z kombinacją naciśniętych klawiszy. W tym celu potrzebny będzie <span class="notranslate">object</span> z przypisaną stroną <span class="notranslate">sprite</span>, której trzeba będzie nadać <strong>zdarzenie Step Event</strong> z następującymi czynnościami lub kodem:</p>
    <p class="dropspot"><img alt="GML VisualStep Event Movement Actions" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_2_2.png" /></p>
    <p class="note"><span class="note">UWAGA</span> Powyżej podzieliliśmy działania wizualne na dwie kolumny, aby ułatwić ich wizualizację, ale w edytorze wizualnym będą one umieszczone po kolei.</p>
    <p class="code">var _left = keyboard_check(vk_left);<br />
      var _right = keyboard_check(vk_right);<br />
      var _up = keyboard_check(vk_up);<br />
      var _down = keyboard_check(vk_down);<br />
      var _hspd = _right - _left;<br />
      var _vspd = _down - _up;</p>
    <p class="dropspot">Aby móc się poruszać, musimy dodać trochę więcej kodu, ale zanim to zrobimy, wyjaśnijmy to trochę. Chcemy przekonwertować wartości lewo/prawo/góra/dół na równoważne wartości prędkości w poziomie i pionie, więc aby to zrobić, pobieramy wartość każdego klawisza, a następnie wykonujemy na niej podstawowe działania matematyczne, aby uzyskać wartości prędkości. Działa to w ten sposób, że jeśli klawisz jest wciśnięty, to akcja lub funkcja sprawdzająca zwróci &quot;1&quot;, a jeśli <em>nie </em>jest wciśnięty, to funkcja zwróci &quot;0&quot;. Tak więc, jeśli na przykład wciśnięto prawy klawisz, to dla &quot; <span class="inline">_hspd</span>&quot; masz &quot;1 - 0 = 1&quot;, a jeśli wciśnięto lewy, to dla &quot; <span class="inline">_hspd</span>&quot; masz &quot;0 - 1 = -1&quot; (a jeśli wciśnięto oba, to &quot;1 - 1 = 0&quot;, więc instancja się nie poruszy). Pamiętaj, że w <span data-keyref="GameMaker Name">GameMakerze</span> <span class="notranslate">room</span>, aby przesunąć się w prawo, dodajemy do pozycji <span class="inline">x </span>, a aby przesunąć się w lewo, odejmujemy, więc ten kod da nam dodatnią lub ujemną wartość, którą możemy dodać lub odjąć, aby przesunąć się w poziomie lub w pionie, zależnie od danych wprowadzonych z klawiatury.</p>
    <p class="dropspot">Teraz możemy dodać kod, który faktycznie przesunie instancję, a więc - nadal w <strong>zdarzeniu Step</strong> i po powyższym kodzie - dodajemy to:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">if (_hspd != 0 || _vspd != 0)<br />
      {<br />
          var _spd = 4;<br />
          var _dir = point_direction(0, 0, _hspd, _vspd);<br />
          var _xadd = lengthdir_x(_spd, _dir);<br />
          var _yadd = lengthdir_y(_spd, _dir);<br />
          x = x + _xadd;<br />
          y = y + _yadd;<br />
      }</p>
    <p class="dropspot">Powyższy kod najpierw sprawdza, czy jedno z dwóch <a class="glossterm" data-glossterm="wyrażenie" href="#">wyrażeń</a>jest prawdziwe, tzn. czy zmienne prędkości poziomej lub pionowej nie są równe 0. Zwróć uwagę, że w sprawdzeniu &quot; <span class="inline">if</span>&quot; <span class="notranslate">GML</span> użyto symbolu &quot; <span class="inline">||</span>&quot;. W języku programowania oznacza to &quot; <span class="inline">or</span>&quot;, a więc - mówiąc wprost - sprawdzasz</p>
    <p class="code">if the variable _hspd does not equal zero<br />
      <strong>or</strong><br />
      if the variable _vspd does not equal zero
    </p>
    <p class="dropspot">W ten sposób można <span class="notranslate">string</span> wiele wyrażeń razem w &quot; <span class="inline">if</span>&quot; sprawdzać, a wyrażenia te mogą być obliczane na wiele różnych sposobów (więcej informacji na ten temat można znaleźć w rozdziale <strong>Wyrażenia</strong> <a href="../GameMaker_Language/GML_Overview/Expressions_And_Operators.htm">tutaj</a>).</p>
    <p class="dropspot">W następnej części kodu zapisujemy w zmiennej wartość rzeczywistej prędkości ruchu, a następnie pobieramy kierunek, korzystając z wartości <span class="inline">_hspd </span>i <span class="inline">_vspd </span>, które mogą wynosić -1, 0 lub 1. Funkcja kierunku sprawdza kierunek od (0, 0), ponieważ nie używamy współrzędnych <span class="notranslate">room</span>, a zamiast tego chcemy, aby na podstawie wartości zmiennych obliczyła kierunek od 0° do 360°. Poniższy diagram lepiej ilustruje to, co się dzieje, niż próby wyjaśnienia tego słowami:</p>
    <p class="dropspot"><img alt="Animation Showing 8-Way Keyboard Movement" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_2_2.gif" /></p>
    <p class="note"><span class="note">UWAGA</span> Kierunek w programie <span data-keyref="GameMaker Name">GameMaker</span> jest obliczany <strong>przeciwnie do ruchu wskazówek zegara</strong>, więc 0° i 360° są w prawo, 90° to góra, 180° to prawo, a 270° to dół.</p>
    <p class="dropspot">Na koniec używamy <a href="../GameMaker_Language/GML_Reference/Maths_And_Numbers/Angles_And_Distance/lengthdir_x.htm"><span class="inline">lengthdir_x()</span></a> oraz <a href="../GameMaker_Language/GML_Reference/Maths_And_Numbers/Angles_And_Distance/lengthdir_y.htm"><span class="inline">lengthdir_y()</span></a> aby faktycznie przesunąć zmienną. Są to <strong> <a class="glossterm" data-glossterm="wektor" href="#">wektor</a>  </strong>które pobierają długość (odległość) i kierunek, a następnie na podstawie tych wartości obliczają nową pozycję na danej osi (bardziej szczegółowe objaśnienia znajdują się w opisach funkcji).</p>
    <p class="dropspot">To bardzo dużo do ogarnięcia na raz i nie przejmuj się, jeśli nie do końca to wszystko rozumiesz! Z czasem zrozumiesz! Teraz pozostaje tylko dodać instancję tej strony <span class="notranslate">object</span> do strony <span class="notranslate">room</span>, a następnie nacisnąć przycisk <strong>Odtwórz </strong><strong> <img></strong>a powinieneś uzyskać jedwabiście gładki ruch w 8 kierunkach, bez żadnych problemów związanych z poruszaniem się po przekątnej:</p>
    <p class="dropspot"><img alt="Getting Gamepad ID Using DnD" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_3_1.png" /></p>
  </div>
  <p> </p>
  <p>Mamy nadzieję, że dzięki tym przykładom - a także poprzednim, dotyczącym rysowania - zrozumieliście wystarczająco dużo, aby zacząć tworzyć własne projekty! Na ostatniej stronie tego podręcznika znajduje się podsumowanie tego, czego się nauczyłeś, a także łącza do dodatkowych materiałów edukacyjnych.</p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Powrót: <a href="../Content.htm">Indeks</a></div>
        <div style="float:right">Następny: <a href="Summary.htm">Podsumowanie</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Wszystkie prawa zastrzeżone.</span></h5>
  </div>
  <!-- KEYWORDS
Movement
Controls
Movement and Controls
Movement Examples
Controls Examples
-->
  <!-- TAGS
qs_movement_controls
-->
</body>
</html>