<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Rysunek</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <script src="../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Some basic code to show people how things are drawn." />
  <meta name="rh-index-keywords" content="Quick Start - Drawing" />
  <meta name="search-keywords" content="drawing,draw event,GUI layer" />
  <meta name="robots" content="NOODP" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Rysunek</h1>
  <p>Ta sekcja (oraz następująca po niej sekcja <a href="Movement_And_Controls.htm">Ruch i sterowanie</a>) ma na celu przedstawienie praktycznych przykładów z <span class="notranslate">GML</span> lub <span class="notranslate">GML</span> Visual, aby umożliwić jak najszybsze rozpoczęcie tworzenia pierwszych projektów gier. Nie będziemy wyjaśniać wszystkiego zbyt dokładnie, ponieważ chcemy, abyś jak najszybciej zaczął tworzyć gry. Zachęcamy więc do zapoznania się z linkami i używania funkcji &quot;szukaj&quot; w podręczniku w celu znalezienia dodatkowych informacji o wszystkim, czego nie jesteś pewien.</p>
  <p>W tym rozdziale skoncentrujemy się na rysowaniu informacji na ekranie, zarówno w postaci tekstu, jak i obrazów, a także wyjaśnimy nieco więcej na temat różnych <strong>zdarzeń</strong> rysowania, a konkretnie głównego zdarzenia <strong>Draw</strong> oraz zdarzenia <strong>Draw GUI </strong>(należy pamiętać, że w niektórych przykładach konieczne będzie dodanie innych zdarzeń, ale wyjaśnimy je, gdy do nich dojdziemy).</p>
  <p><img alt="The Draw Events" class="center" src="../assets/Images/QS_Guide/QS_DrawEvents.png" /></p>
  <p>Zanim przejdziemy dalej, warto utworzyć nowy projekt ( <span class="notranslate">GML</span> lub <span class="notranslate">GML</span> Visual) na <a href="../Introduction/The_Start_Page.htm">stronie startowej</a> i dodać (lub utworzyć) kilka <a href="../Introduction/The_Start_Page.htm">stron</a> <span class="notranslate">sprites</span> oraz jedną lub dwie <span class="notranslate">object</span>, ponieważ będziemy podawać kod, który można przetestować przy ich użyciu. Na razie wystarczy nawet biały kwadrat jako <span class="notranslate">sprite</span> dla naszego <span class="notranslate">object</span>!</p>
  <p>Jak wspomniano w rozdziale <a href="Objects_And_Instances.htm">Obiekty i instancje</a>, jeśli nie dodasz zdarzenia Draw Event do <span class="notranslate">object</span>, <span data-keyref="GameMaker Name">GameMaker</span> będzie domyślnie rysował, co oznacza, że jeśli do <span class="notranslate">object</span> jest przypisana strona <span class="notranslate">sprite</span>, to ta strona <span class="notranslate">sprite</span> zostanie narysowana wraz z dodanymi transformacjami. Co rozumiemy przez transformacje? Otóż każda strona <span class="notranslate">object</span> ma pewną liczbę wbudowanych <a class="glossterm" data-glossterm="zmienna" href="#">zmiennych</a>, które kontrolują sposób, w jaki instancja <span class="notranslate">object</span> rysuje swoją stronę <span class="notranslate">sprite</span> podczas rysowania domyślnego, a Ty możesz zmieniać te zmienne w trakcie gry, aby zmienić sposób rysowania strony <span class="notranslate">sprite</span>.</p>
  <p class="note"><strong>UWAGA</strong>: Listę wszystkich wbudowanych zmiennych, których można używać do przekształcania instancji, można znaleźć <a href="../GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Instance_Variables/Sprite_Instance_Variables.htm">tutaj</a> <span class="notranslate">sprites</span>. <span class="notranslate">GML</span> Użytkownicy Visual mają kilka dedykowanych akcji, które wpływają na te zmienne, które można znaleźć <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Drawing/Drawing_Actions.htm">tutaj</a>, można też użyć samych zmiennych wraz z akcjami <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Instance/Get_Instance_Variable.htm">Get Instance Variable</a> i <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Instance/Set_Instance_Variable.htm">Set</a> Instance Variable.</p>
  <p>Przyjrzyjmy się kilku przykładom:</p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down" href="#">Zmiana współczynnika alfa (przezroczystości)</a></p>
  <div class="droptext" data-targetname="drop_down">
    <p class="dropspot">Wartość <strong>alfa </strong>kontroluje przezroczystość rysowanych elementów, a w <span data-keyref="GameMaker Name">GameMakerze</span> można użyć wbudowanej zmiennej <span class="inline">image_alpha</span>, aby zmienić przezroczystość przypisanej do niej strony <span class="notranslate">sprite</span>. Aby zobaczyć, jak to działa, otwórz (lub utwórz) stronę <span class="notranslate">object</span>, przypisz jej adres <span class="notranslate">sprite</span>, a następnie nadaj stronie <span class="notranslate">object</span> <strong>zdarzenie Create Event</strong>. W zdarzeniu Create Event wystarczy dodać następującą stronę <span class="notranslate">GML</span> Visual lub GML:</p>
    <p class="dropspot"><img alt="GML VisualDraw Example For Transparency" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_1.png" /></p>
    <p class="code">var _val = random(1);
      <br />
      image_alpha = _val;
    </p>
    <p class="dropspot">Wartość alfa obrazu jest obliczana jako wartość z zakresu od 0 do 1, gdzie 0 oznacza pełną przezroczystość, a 1 pełną nieprzezroczystość (domyślnie ustawiona jest na 1). W tym przykładzie ustawiamy więc tylko alfa obrazu na losową wartość dziesiętną z zakresu od 0 do 1. Umieść kilka instancji tej strony <span class="notranslate">object</span> na stronie <span class="notranslate">room</span>, a następnie kliknij przycisk <strong>Odtwórz </strong> <img> w górnej części strony <span class="notranslate">IDE</span>.</p>
    <p class="dropspot">Należy zauważyć, że każda instancja strony <span class="notranslate">object</span> rysuje swoją stronę <span class="notranslate">sprite</span> z inną przezroczystością, np:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down1" href="#">Zmiana mieszanki kolorów (barwienie)</a></p>
  <div class="droptext" data-targetname="drop_down1">
    <p class="dropspot">Gdy na stronie <span class="notranslate">object</span> domyślnie rysowana jest strona <span class="notranslate">sprite</span>, ta strona <span class="notranslate">sprite</span> jest w rzeczywistości rysowana z <strong>domieszką </strong>(lub <strong>zabarwiona</strong>) koloru, a wartość tego koloru jest przechowywana we wbudowanej zmiennej <span class="inline">image_blend</span>. Domyślnie kolor ten jest biały, co oznacza, że do strony <span class="notranslate">sprite</span> nie zostanie dodany żaden kolor podczas wyświetlania jej na ekranie. Można jednak używać innych kolorów, aby uzyskać efekty specjalne, np. użyć koloru czerwonego, aby pokazać, że instancja otrzymała pewne obrażenia.</p>
    <p class="dropspot">W tym przykładzie zamierzamy mieszać różne kolory z <span class="notranslate">sprite</span>, gdy klawisz jest naciśnięty i przytrzymany, dlatego należy otworzyć (lub utworzyć) stronę <span class="notranslate">object</span>, przypisać jej adres <span class="notranslate">sprite</span>, a następnie nadać <span class="notranslate">object</span> <strong>zdarzenie Key Down &lt;Space&gt; Event</strong>.</p>
    <p class="dropspot"><img alt="Example Of Sprites Drawn With Different Alpha Values" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_1.png" /></p>
    <p class="dropspot">W tym zdarzeniu Key Down Event dodaj następującą stronę <span class="notranslate">GML</span> Visual lub GML:</p>
    <p class="dropspot"><img alt="Add Key Down Event" class="center" src="../assets/Images/QS_Guide/QS_Add_SpaceKeyPressEvent.png" /></p>
    <p class="code">var _col = choose(c_red, c_green, c_blue, c_yellow, c_fuchsia, c_orange);
      <br />
      image_blend = _col;
    </p>
    <p class="dropspot">Umieść kilka instancji tej strony <span class="notranslate">object</span> na stronie <span class="notranslate">room</span>, a następnie kliknij przycisk Odtwarzaj <img> w górnej części strony <span class="notranslate">IDE</span> i przetestuj, czy można przytrzymać i zwolnić klawisz <em>spacji </em>. Powinieneś zauważyć, że każda instancja będzie szybko zmieniać kolor, gdy klawisz jest przytrzymany, i przestanie się zmieniać, gdy zostanie zwolniony:</p>
    <p class="dropspot"><img alt="GML VisualExample Using Key Down Event" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_2.png" /></p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down2" href="#">Zmiana skali</a></p>
  <div class="droptext" data-targetname="drop_down2">
    <p class="dropspot">Kolejną właściwością, którą możemy zmienić w naszym arkuszu <span class="notranslate">sprite</span>, jest wartość <strong>skali </strong>, co pozwala nam rysować go w większym lub mniejszym rozmiarze, kiedy tylko chcemy. Skalę oblicza się niezależnie wzdłuż osi X i Y za pomocą dwóch osobnych zmiennych, zmiennej <span class="inline">image_xscale</span> i zmiennej <span class="inline">image_yscale</span>. Domyślnie są one ustawione na 1 i działają jak <strong>mnożniki</strong>, więc wartość 0,5 oznacza połowę skali, a wartość 2 - podwojenie skali.</p>
    <p class="note"><strong>WAŻNE! </strong>Zmiana skali strony <span class="notranslate">sprite</span> przy użyciu tych zmiennych <strong>spowoduje również zmianę rozmiaru ramki ograniczającej</strong>, co oznacza, że obszar wykrywania kolizji dla strony <span class="notranslate">sprite</span> również się zmniejszy.</p>
    <p class="dropspot">W tym przykładzie użyjemy kilku prostych metod matematycznych, aby utworzyć instancję skalującą stronę <span class="notranslate">sprite</span> w górę i w dół na stronie <span class="notranslate">loop</span>. Na początek otwórz (lub utwórz) stronę <span class="notranslate">object</span>, przypisz ją do strony <span class="notranslate">sprite</span>, a następnie nadaj stronie <span class="notranslate">object</span> zdarzenie <strong>Create Event</strong>. W tym zdarzeniu dodaj następujące elementy:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">timer = 0;</p>
    <p class="dropspot">Teraz dodaj <strong>zdarzenie Step Event</strong> do strony <span class="notranslate">object</span> w następujący sposób:</p>
    <p class="dropspot"><img alt="Example Showing Colour Blending" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_2.png" /></p>
    <p class="code">timer = timer + 1;
      <br />
      var _val = dsin(timer);
      <br />
      image_xscale = 1 + _val;
      <br />
      image_yscale = 1 + _val;
    </p>
    <p class="dropspot">Używamy tutaj funkcji matematycznej <a href="../GameMaker_Language/GML_Reference/Maths_And_Numbers/Angles_And_Distance/dsin.htm"><span class="inline">dsin()</span></a> do wygenerowania wartości z przedziału od -1 do 1 przy użyciu zmiennej timer, a następnie zastosowania jej do zmiennych skali. Po umieszczeniu kilku instancji w witrynie <span class="notranslate">room</span> i naciśnięciu przycisku <strong>Odtwórz </strong> <img> powinieneś zobaczyć, jak instancje skalują się w górę i w dół od skali 0 do skali 2 i z powrotem.</p>
    <p class="dropspot"><img alt="GML VisualSet Variable Example" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_3_1.png" /></p>
    <p class="dropspot">I ostatnia rzecz... zmień sekcję &quot; <span class="inline">image_yscale</span>&quot; na &quot; <span class="inline">1 - _val</span>&quot; i zobacz, co się stanie!</p>
    <p class="dropspot"> </p>
  </div>
  <p> </p>
  <p>Powyższe przykłady ilustrują niektóre z wielu sposobów manipulowania stroną <span class="notranslate">object</span> <span class="notranslate">sprite</span>, gdy <span data-keyref="GameMaker Name">GameMaker</span> domyślnie rysuje, ale co zrobić, gdy chcesz narysować więcej niż jedną rzecz na stronie <span class="notranslate">object</span>? W takich przypadkach musisz użyć <strong>zdarzenia Draw Event</strong>, aby wyraźnie powiedzieć <span data-keyref="GameMaker Name">GameMakerowi</span>, co ma narysować, co właśnie zrobimy w poniższych przykładach.</p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down3" href="#">Rysowanie dwóch (lub więcej) stron <span class="notranslate">Sprites</span> razem</a></p>
  <div class="droptext" data-targetname="drop_down3">
    <p class="dropspot">W tym przykładzie potrzebne będą dwie strony <span class="notranslate">sprites</span> i jedna <span class="notranslate">object</span>. Nazwij te strony <span class="notranslate">sprites</span> &quot; <span class="inline">spr_One</span>&quot; i &quot; <span class="inline">spr_Two</span>&quot;, a następnie ustaw początek strony &quot; <span class="inline">spr_One</span>&quot; na środku, a dla strony &quot; <span class="inline">spr_Two</span>&quot; ustaw jej początek na środku po lewej stronie:</p>
    <p class="dropspot"><img>Przypisz pierwszą stronę <span class="notranslate">sprite</span> (&quot; <span class="inline">spr_One</span>&quot; z centralnym początkiem) do utworzonej strony <span class="notranslate">object</span>, a następnie dodaj <strong>zdarzenie Create Event</strong>. W zdarzeniu Create Event dodaj następującą stronę <span class="notranslate">GML</span> Visual lub GML:</p>
    <p class="dropspot"><img alt="GML VisualActions To Change Sprite Scale" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_3_2.png" /></p>
    <p class="code">draw_angle = 0;</p>
    <p class="dropspot">Użyjemy tej zmiennej, by obracać &quot; <span class="inline">spr_Two</span>&quot; w czasie i narysować ją nałożoną na <span class="notranslate">sprite</span> przypisaną do <span class="notranslate">object</span> (&quot; <span class="inline">spr_One</span>&quot;). Aby to zrobić, musimy dodać <strong>zdarzenie Draw Event </strong>do <span class="notranslate">object</span>. W ten sposób mówimy <span data-keyref="GameMaker Name">GameMakerowi</span>, że chcemy przejąć to, co rysuje instancja, co oznacza, że nasz kod będzie zawierał wywołanie funkcji <a href="../GameMaker_Language/GML_Reference/Drawing/Sprites_And_Tiles/draw_self.htm"><span class="inline">draw_self()</span></a> funkcji lub <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Drawing/Draw_Self.htm"><strong>Rysuj siebie</strong></a> action. Ta akcja po prostu powiela to, co robi <span class="notranslate">object</span>, gdy nie ma zdarzenia Draw Event i domyślnie rysuje przypisaną mu <span class="notranslate">sprite</span>. Następnie narysujemy drugą stronę <span class="notranslate">sprite</span>, którą chcemy wykorzystać jako nakładkę <span class="notranslate">sprite</span>, która się obraca. Wygląd strony <span class="notranslate">GML</span> Visual i <span class="notranslate">GML</span> wygląda następująco:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">draw_self();
      <br />
      draw_angle = draw_angle + 0.5;
      <br />
      draw_sprite_ext(spr_Two, 0, x, y, 1, 1, draw_angle, c_red, 1);
    </p>
    <p class="dropspot">Dodaj kilka instancji pliku <span class="notranslate">object</span> do edytora <span class="notranslate">room</span>, a następnie naciśnij przycisk <strong>Odtwórz </strong> <img> znajdujący się w górnej części <a class="glossterm" data-glossterm="IDE" href="#">IDE</a>. Jeśli wszystko przebiegło prawidłowo, powinieneś zobaczyć coś takiego:</p>
    <p class="dropspot"><img class="center" src="../assets/Images/QS_Guide/QS_DrawExample_3.gif" title="Animation Showing Sprite Scaling" /></p>
    <p class="dropspot">Zanim opuścimy ten przykład, zmodyfikujmy go nieco i zamiast po prostu obracać &quot; <span class="inline">spr_Two</span>&quot;, sprawimy, że będzie on skierowany w stronę pozycji myszy. W tym celu musimy zmienić zdarzenie Draw Event <span class="notranslate">GML</span> Visual lub <span class="notranslate">GML</span>, aby wyglądało tak:</p>
    <p class="dropspot"><img alt="Show Origins For Sprites" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_4_1.png" /></p>
    <p class="code">draw_self();
      <br />
      draw_angle = point_direction(x, y, mouse_x, mouse_y);
      <br />
      draw_sprite_ext(spr_Two, 0, x, y, 1, 1, draw_angle, c_red, 1);
    </p>
    <p class="dropspot">Uruchom projekt ponownie i tym razem zobaczysz coś zupełnie innego!</p>
    <p class="dropspot"><img>Teraz strona <span class="notranslate">sprite</span> jest skierowana w stronę myszy, niezależnie od tego, w którą stronę ją przesuniesz! Jak widać, nakładanie warstw na stronę <span class="notranslate">sprites</span> to świetny sposób na dodanie szczegółów do strony <span class="notranslate">object</span> lub sprawienie, by coś poruszało się niezależnie od &quot;bazowej&quot; strony <span class="notranslate">sprite</span> przypisanej do <span class="notranslate">object</span>. Jest to potężne narzędzie, którego prawdopodobnie będziesz często używać w swoich projektach.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down4" href="#">Rysowanie rzeczy innych niż sprite'y</a></p>
  <div class="droptext" data-targetname="drop_down4">
    <p class="dropspot">W zdarzeniu Draw można rysować także inne rzeczy niż <span class="notranslate">sprites</span>, na przykład tekst lub kształty. W tym przykładzie użyjemy funkcji <span class="notranslate">GML</span> Visual lub <span class="notranslate">GML</span> <span class="inline">draw_self()</span> do narysowania elementu <span class="notranslate">object</span> <span class="notranslate">sprite</span>, ale narysujemy też inne rzeczy, zaczynając od <strong>tekstu</strong>. Do tego przykładu potrzebne będą funkcje <span class="notranslate">sprite</span> i <span class="notranslate">object</span> (z przypisaną do niej funkcją <span class="notranslate">sprite</span> ). Na stronie <span class="notranslate">object</span> dodaj najpierw <strong>zdarzenie Create Event</strong> z tym <span class="notranslate">GML</span> Visual lub GML:</p>
    <p class="dropspot"><img alt="Set Draw Angle Variable In DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_4_1.png" /></p>
    <p class="code">name = choose(&quot;Fred&quot;, &quot;Jonas&quot;, &quot;Sharon&quot;, &quot;Kate&quot;, &quot;Frank&quot;, &quot;John&quot;, &quot;Monica&quot;, &quot;Amanda&quot;);
      <br />
      number = irandom(100);
    </p>
    <p class="dropspot">To wszystko każe programowi <span data-keyref="GameMaker Name">GameMaker</span> wybrać jedną z wymienionych nazw i przypisać ją do zmiennej, a także wygenerować losową liczbę od 0 do 100 dla każdej instancji <span class="notranslate">object</span>. Chcemy narysować te wartości na ekranie, więc w tym celu należy dodać <strong>zdarzenie Draw Event</strong>, a w nim następującą stronę <span class="notranslate">GML</span> Visual lub GML:</p>
    <p class="dropspot"><img alt="Draw Two Sprites With DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_4_2.png" /></p>
    <p class="code">draw_self();
      <br />
      draw_set_halign(fa_center);
      <br />
      draw_text(x, y + 32, &quot;My name is &quot; + name);
      <br />
      draw_text(x, y + 48, &quot;My number is &quot; + string(number));
    </p>
    <p class="dropspot">W powyższym kodzie można zauważyć, że używamy funkcji <a href="../GameMaker_Language/GML_Reference/Strings/string.htm"><span class="inline">string()</span></a> lub <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Data_Types/Number_To_String.htm"><strong>Number To String</strong></a> na zmiennej &quot;liczba&quot;, którą chcemy narysować. Dzieje się tak dlatego, że cały tekst musi składać się ze <em>znaków</em>, a nie z wartości, dlatego musimy użyć tej funkcji/działania, aby przekształcić wartość liczbową w znaki, które chcemy narysować. W tym przypadku bierzemy wygenerowaną przez nas liczbę losową i zamieniamy ją w &quot;ciąg&quot; znaków, który można narysować. Zwróć też uwagę, że ustawiliśmy <strong>wyrównanie</strong> tekstu. W tym przypadku chcemy, aby tekst był wyśrodkowany wzdłuż osi x. Dzięki temu <span data-keyref="GameMaker Name">GameMaker</span> będzie wiedział, w którym miejscu ma zacząć rysować tekst w stosunku do podanej pozycji.</p>
    <p class="dropspot">Dodaj kilka instancji pliku <span class="notranslate">object</span> do edytora <span class="notranslate">room</span>, a następnie naciśnij przycisk Odtwórz <img> w górnej części strony <span class="notranslate">IDE</span>. Powinieneś zobaczyć coś takiego:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="dropspot">We wszystkich dotychczasowych przykładach rysowaliśmy na stronie <span class="notranslate">sprite</span> przypisanej do instancji, ale nie zawsze musi tak być. W zdarzeniu draw <strong>można narysować wszystko, co</strong> się chce, niezależnie od przypisanego adresu <span class="notranslate">sprite</span>. Aby zilustrować tę kwestię, zmienimy nasz obecny kod, usuwając wywołanie <span class="inline">draw_self()</span> i zastępując je funkcją rysującą kolorową elipsę, jak poniżej:</p>
    <p class="dropspot"><img alt="Animation Drawing Two Sprites Together" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_4_2.gif" /></p>
    <p class="code">draw_ellipse_colour(x - 50, y - 32, x + 50, y + 32, c_fuchsia, c_lime, false);
      <br />
      draw_set_halign(fa_center);
      <br />
      draw_text(x, y + 32, &quot;My name is &quot; + name);
      <br />
      draw_text(x, y + 48, &quot;My number is &quot; + string(number));
    </p>
    <p class="dropspot">Uruchom ponownie projekt, a zobaczysz to:</p>
    <p class="dropspot"><img alt="Edited Draw Code For Drawing Two Sprites With DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_4_3.png" /></p>
    <p class="dropspot">Należy zwrócić uwagę na jedną ważną rzecz: nawet jeśli nie rysujemy przypisanego elementu <span class="notranslate">sprite</span>, <strong>będzie on nadal używany do wykrywania kol</strong>izji. Tak więc podczas rysowania jednej rzeczy, kolizje nadal będą obliczane na podstawie przypisanej strony <span class="notranslate">sprite</span>, tak jakby była ona umieszczona na stronie <span class="notranslate">room</span> razem z instancją, nawet jeśli nie jest widoczna. Jest to całkiem przydatne, ponieważ oznacza, że możesz rysować różne <span class="notranslate">sprites</span>, ale zachować jedną <strong>maskę</strong> kolizji opartą na przypisanej <span class="notranslate">sprite</span>. Zauważ też, że nadal możesz stosować różne przekształcenia, takie jak skala X/Y, a kolizje będą oparte na zmienionym rozmiarze, mimo że nic nie jest rysowane, aby to pokazać.</p>
  </div>
  <p> </p>
  <p> </p>
  <h1>Warstwa GUI</h1>
  <p>Na górze strony wspomnieliśmy, że będziemy mówić o <strong>zdarzeniu</strong> Rysuj interfejs graficzny oraz o zdarzeniu Rysuj, więc przyjrzyjmy się teraz temu. Zdarzenie Draw GUI działa na czymś, co nazywa się <strong> warstwą <a class="glossterm" data-glossterm="GUI" href="#">GU</a></strong> <strong> <a class="glossterm" data-glossterm="GUI" href="#">I</a></strong>, czyli specjalną warstwą rysunkową o stałej szerokości i wysokości, która jest rysowana nad instancjami w witrynie <span class="notranslate">room</span>. Zaletą warstwy GUI jest to, że <em> nie porusza się ona wraz z kamerą <span class="notranslate">room</span> </em>, więc jest to idealne miejsce do dodawania statycznych elementów GUI, takich jak wyniki, paski zdrowia i inne informacje, które gra musi przekazywać użytkownikowi. Więcej informacji na temat warstwy GUI można znaleźć w części podręcznika poświęconej <a href="../The_Asset_Editors/Object_Properties/Draw_Events.htm">zdarzeniom rysowania</a>.</p>
  <p class="note"><strong>UWAGA</strong>: Strona <span class="notranslate">Rooms</span> może być większa niż rozmiar ekranu, dlatego można tworzyć duże poziomy, po których gracz będzie się poruszał. Oznacza to, że w edytorze <span class="notranslate">Room</span> (lub w kodzie) należy zdefiniować <strong>kamerę </strong>, która będzie podążać za akcją gry. Jest to sposób na ustawienie stałego obszaru ekranu, na którym wyświetlane są różne części większej strony <span class="notranslate">room</span>, na przykład w zależności od pozycji gracza na stronie <span class="notranslate">room</span>. Przypomnij sobie, że w klasycznych grach, takich jak Mario czy Zelda, widok zawsze podąża za głównym bohaterem. Jest to możliwe dzięki kamerom. Więcej informacji można znaleźć w rozdziale <a href="../The_Asset_Editors/Room_Properties/Room_Properties.htm">Właściwości pomieszczenia</a> na stronie <span class="notranslate">Room</span> w sekcji Edytor.</p>
  <p>Wszystkie poniższe przykłady będą korzystać ze zdarzenia <strong>Draw GUI</strong>, dlatego należy utworzyć stronę <span class="notranslate">object</span> i dodać do niej to zdarzenie. Zauważ, że <span class="notranslate">object</span> nie potrzebuje przypisanego <span class="notranslate">sprite</span>, ponieważ nie chcemy, aby domyślnie rysował cokolwiek, ani nie potrzebujemy go do wykrywania kolizji. <span class="notranslate">Objects</span> takie jak to, które są przeznaczone tylko do rysowania rzeczy lub kontrolowania pewnych aspektów gry, są często nazywane <strong>obiektami kontrolera</strong>. Zwróć uwagę, że we wszystkich przykładach będziemy używać tego samego adresu <span class="notranslate">object</span>, dlatego zalecamy, abyś zapoznał się z nimi po kolei (choć nie jest to konieczne).</p>
  <p><img> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down5" href="#">Rysowanie tekstu</a></p>
  <div class="droptext" data-targetname="drop_down5">
    <p class="dropspot">Podczas rysowania na warstwie GUI lewy górny róg jest pozycją początkową, natomiast w prawo jest +X, a w dół +Y. Dzięki temu pozycjonowanie tekstu i grafiki jest bardzo proste, o czym przekonasz się na tym przykładzie. Wszystko, co zamierzamy tutaj zrobić, to narysować wartość, która reprezentuje wynik gracza, więc w naszym <span class="notranslate">object</span> musimy dodać <strong>zdarzenie Create Event </strong>, aby zainicjować zmienną, która będzie przechowywać tę wartość, tak jak poniżej:</p>
    <p class="dropspot"><img alt="Animation Drawing Two Sprites Pointing At Mouse" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_4_3.gif" /></p>
    <p class="code">player_score = 0;</p>
    <p class="dropspot">Chcemy także dodać <strong>zdarzenie Keyboard Down &lt;Space&gt;</strong> do strony <span class="notranslate">object</span>, ponieważ będziemy go używać do zwiększania wyniku po każdym naciśnięciu klawisza spacji.</p>
    <p class="dropspot"><img alt="Setting Variables Using DnD" class="center" height="506" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_5_1_1.png" width="317" /></p>
    <p class="dropspot">W tym przypadku należy dodać następujące elementy:</p>
    <p class="dropspot"><img alt="Drawing Text Using DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_5_1.png" /></p>
    <p class="code">var _val = irandom(100);
      <br />
      player_score = player_score + _val;
    </p>
    <p class="dropspot">Na koniec narysujmy wartość punktową w zdarzeniu Draw GUI, tak jak poniżej:</p>
    <p class="dropspot">W tym przypadku należy dodać następujące elementy:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">draw_set_halign(fa_left);
      <br />
      draw_set_colour(c_yellow);
      <br />
      draw_text(32, 32, &quot;SCORE:&quot;);
      <br />
      draw_set_colour(c_white);
      <br />
      var _str = string(player_score);
      <br />
      draw_text_transformed(32, 48, _str, 2, 2, 0);
    </p>
    <p class="dropspot">Zauważysz, że użyliśmy <a class="glossterm" data-glossterm="twardo zakodowane" href="#">twardo zakodowanych</a> (lub stałych) wartości dla pozycji x/y rysowanego tekstu, ponieważ nie potrzebujemy, aby był on względny w stosunku do jakiejkolwiek instancji, ponieważ rysujemy na warstwie GUI. Użyliśmy także funkcji &quot;ustaw kolor&quot;, aby zmienić kolor tekstu, oraz funkcji &quot;przekształć&quot;, aby zwiększyć rzeczywistą wartość wyniku, co ilustruje, jak można dostosować elementy tekstowe w swoich grach.</p>
    <p class="dropspot">Dodaj teraz pojedynczą instancję tej strony <span class="notranslate">object</span> do swojej strony <span class="notranslate">room</span>, a następnie naciśnij przycisk <strong>Play </strong>(Graj) <img>. Gdy gra się uruchomi, naciśnij i zwolnij przycisk <span class="inline">&lt;Space&gt;</span>, a powinieneś zobaczyć, jak rośnie wartość punktacji.</p>
    <p class="dropspot"><img alt="Sprites Being Drawn Along With Text" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_5_1.png" /></p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down6" href="#">Rysowanie sprite'ów</a></p>
  <div class="droptext" data-targetname="drop_down6">
    <p class="dropspot">W tym przykładzie użyjemy warstwy GUI do narysowania strony <span class="notranslate">sprites</span>. Najbardziej oczywistym zastosowaniem jest narysowanie życia graczy, więc zróbmy to! Do tego przykładu będzie potrzebna strona <span class="notranslate">sprite</span> - powinna ona mieć rozmiar około 64x64 pikseli - ale nie powinna być przypisana do strony <span class="notranslate">object</span>, ponieważ będziemy ją rysować sami.</p>
    <p class="dropspot">Na początek musimy dodać kilka nowych zmiennych do strony <span class="notranslate">object</span> w <strong>zdarzeniu Utwórz</strong> (jeśli korzystałeś z poprzedniego przykładu, dodaj poniższe zmienne poniżej tego, co już tam jest):</p>
    <p class="dropspot"><img alt="Drawing Shapes Along With Text Using DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_5_2.png" /></p>
    <p class="code">player_lives = 3;
      <br />
      gui_w = display_get_gui_width();
    </p>
    <p class="dropspot">W tym kodzie inicjalizujemy zmienną dla życia gracza, ale tworzymy także zmienną, która przechowuje szerokość warstwy GUI, abyśmy mogli prawidłowo rozmieścić elementy względem prawej strony ekranu. Moglibyśmy po prostu na sztywno zakodować wartość w kodzie i użyć jej, ale oznaczałoby to, że jeśli później zmienimy rozmiar strony <span class="notranslate">room</span>, lub jeśli dodamy kamery itp. Użycie <a href="../GameMaker_Language/GML_Reference/Cameras_And_Display/display_get_gui_width.htm"><span class="inline">display_get_gui_width()</span></a> oznacza, że nie musimy się martwić o żadne tego typu zmiany w przyszłości, ponieważ kod automatycznie dostosuje się do rozmiaru warstwy GUI.</p>
    <p class="dropspot">Następnie chcemy dodać <strong>zdarzenie Naciśnięcie</strong> klawisza <strong>&lt;Enter&gt;</strong> do strony <span class="notranslate">object</span>, ponieważ będziemy go używać do zmiany liczby żyć po każdym naciśnięciu klawisza Enter:</p>
    <p class="dropspot"><img alt="Example Of Drawing Shapes And Text Together" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_5_2.png" /></p>
    <p class="dropspot">W tym przypadku należy dodać następujące elementy:</p>
    <p class="dropspot"><img alt="Draw GUI Event In An Object" class="center" src="../assets/Images/QS_Guide/QS_DrawGUIObject.png" /></p>
    <p class="code">player_lives = player_lives - 1;
      <br />
      <br />
      if player_lives &lt; 0
      <br />
      {
      <br />
      player_lives = 3;
      <br />
      }
    </p>
    <p class="dropspot">Na koniec musimy narysować na ekranie stronę <span class="notranslate">sprites</span>. W tym celu użyjemy &quot; <span class="inline">for</span>&quot; <span class="notranslate">loop</span> (informacje o użyciu <span class="notranslate">GML</span> <a href="../GameMaker_Language/GML_Overview/Language_Features/for.htm">tutaj</a>, a dla <span class="notranslate">GML</span> Visual <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Loops/For.htm">tutaj</a>), wraz ze zmienną GUI width, aby umieścić wszystko w prawym górnym rogu ekranu. Dlatego dodaj to do zdarzenia Draw Gui (po innych akcjach, które mogą być wykonane w poprzednich przykładach):</p>
    <p class="dropspot"><img alt="Defining A Variable Using DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_6_1.png" /></p>
    <p class="code">for (var i = 0; i &lt; player_lives; i += 1)
      <br />
      {
      <br />
      var _xx = gui_w - 48 - (i * 70);
      <br />
      draw_sprite(spr_Heart, 0, _xx, 48);
      <br />
      }
    </p>
    <p class="dropspot">Jeśli jeszcze nie dodałeś instancji tej gry <span class="notranslate">object</span> do gry <span class="notranslate">room</span>, dodaj ją teraz (tylko jedną!), a następnie naciśnij przycisk <strong>Odtwórz </strong> <img>. Po uruchomieniu gry naciskaj wielokrotnie klawisz <span class="inline">&lt;Enter&gt;</span>, aby zobaczyć, jak zmieniają się życia.</p>
    <p class="dropspot"><img alt="Adding A Space Key Pressed Event" class="center" src="../assets/Images/QS_Guide/QS_Add_SpaceKeyPressEvent.png" /></p>
    <p class="dropspot">Zanim opuścisz ten przykład, powinieneś poeksperymentować z liczbą żyć i zobaczyć, co się stanie. W tej chwili jest ona ustawiona na 3, ale zmień zdarzenie tworzenia i zdarzenie naciśnięcia klawisza, aby ustawić wartość na 5 lub 10... jeśli wszystko zrobiłeś dobrze, to kod powinien się dostosować i narysować je wszystkie poprawnie!</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down7" href="#">Rysowanie paska zdrowia</a></p>
  <div class="droptext" data-targetname="drop_down7">
    <p class="dropspot">Ostatni przykład dotyczy rysowania paska zdrowia na warstwie GUI. Można to zrobić na wiele sposobów, ale <span data-keyref="GameMaker Name">GameMaker</span> ma wbudowaną funkcję specjalnie do tworzenia pasków zdrowia, więc właśnie jej użyjemy, choć można też tworzyć własne, używając <span class="notranslate">sprites</span> lub kształtów. Na początek, tak jak poprzednio, musimy zainicjować zmienną, która będzie przechowywać wartość stanu zdrowia, więc dodaj poniższy kod <span class="notranslate">GML</span> Visual lub <span class="notranslate">GML</span> do <strong>zdarzenia Create Event</strong> na stronie <span class="notranslate">object</span> (po innym kodzie, który może się tam już znajdować):</p>
    <p class="dropspot"><img alt="GML VisualActions In The Space Key Event" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_6_2.png" /></p>
    <p class="code">player_health = 100;</p>
    <p class="dropspot">Chcemy użyć klawiszy strzałek do zmiany wartości stanu zdrowia w górę lub w dół w zależności od tego, który klawisz strzałki zostanie naciśnięty. Można to zrobić, dodając dwa zdarzenia <strong>&lt;strzałka&gt; naciśnięte na klawiaturze</strong>, ale prawdopodobnie łatwiej będzie użyć zdarzenia <strong>Step Event</strong> i kodu sprawdzającego klawisze, więc dodaj teraz zdarzenie <strong>Step Event</strong>, korzystając z następującej strony <span class="notranslate">GML</span> Visual lub GML:</p>
    <p class="dropspot"><img alt="Drawing Text To The GUI Layer Using DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_6_3.png" /></p>
    <p class="code">if keyboard_check(vk_up)<br />
      {<br />
          if player_health &lt; 100<br />
          {<br />
              player_health = player_health + 1;<br />
          }<br />
      }<br />
      <br />
      if keyboard_check(vk_down)<br />
      {<br />
          if player_health &gt; 0<br />
          {<br />
              player_health = player_health - 1;<br />
          }<br />
      }
    </p>
    <p class="dropspot">Po wykonaniu tych czynności możemy zająć się rysowaniem paska zdrowia, co wykonujemy w zdarzeniu Draw GUI, dodając następujące elementy (po wszystkich innych, które już tam są):</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">var _xx = display_get_gui_width() / 2;<br />
      <br />
      draw_healthbar(_xx - 50, 24, _xx + 50, 40, player_health, c_black, c_red, c_lime, 0, true, true);
    </p>
    <p class="dropspot">Dodaj instancję tej strony <span class="notranslate">object</span> do strony <span class="notranslate">room</span>, jeśli jeszcze tego nie zrobiłeś (ale tylko jedną!), a następnie naciśnij przycisk <strong>odtwarzania </strong> <img>. Po uruchomieniu gry naciśnij kilka razy przyciski <span class="inline">&lt;Up Arrow&gt;</span> i <span class="inline">&lt;Down Arrow&gt;</span>, aby zobaczyć, jak zmienia się stan zdrowia.</p>
    <p class="dropspot"><img alt="Animation Showing Text Being Drawn To The GUI Layer" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_6.gif" /></p>
  </div>
  <p> </p>
  <p>Mamy nadzieję, że po wykonaniu tych przykładów nabierzesz pewności siebie podczas korzystania z <span data-keyref="GameMaker Name">GameMakera</span> i lepiej zrozumiesz, jak to wszystko działa. W następnej części dowiesz się, jak sprawić, by narysowane przez Ciebie przedmioty poruszały się po stronie <span class="notranslate">room</span>, a także akceptowały i reagowały na polecenia użytkownika.</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Powrót: <a href="../Content.htm">Indeks</a></div>
        <div style="float:right">Następny: <a href="Movement_And_Controls.htm">Ruch i sterowanie</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Wszystkie prawa zastrzeżone.</span></h5>
  </div>
  <!-- KEYWORDS
Drawing
Drawing Examples
Quick Start Drawing
-->
  <!-- TAGS
qs_drawing
-->
</body>
</html>